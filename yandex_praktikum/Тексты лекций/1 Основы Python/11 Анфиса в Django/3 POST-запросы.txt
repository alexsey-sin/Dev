POST-запросы

Вы научились жонглировать данными из приложений anfisa и icecream, но если у
пользователя не будет возможности отправить на сервер информацию о том, какого
друга и каким мороженым он хочет угостить — проект не заработает.

Отправить данные на сервер можно запросом к определённому адресу. Но как
упаковать в запрос ту информацию, которую нужно передать?

GET & POST запросы

Вы ежедневно отправляете сотни запросов из браузера на всевозможные сайты.
Смотрите страницы, авторизуетесь, делаете онлайн заказы или пишете сообщения
в соцсетях.

Эти запросы, в основном, делятся на две группы.

GET-запросы отправляются в тех случаях, когда в ответ нужно получить какую-нибудь
страницу или информацию от сервера. Когда вы набираете адрес сайта в адресной
строке или щёлкаете по ссылке — вы делаете GET-запрос к серверу.

На протяжении всех предыдущих уроков вы отправляли и обрабатывали именно
GET-запросы, не задумываясь об этом.

    Журден. Как?! Когда я говорю: "Николь, принеси мне туфли и подай
	ночной колпак", — это проза?
    
	Учитель философии. Да, сударь.
    
	Журден. Скажите на милость! Сорок с лишком лет говорю прозой — и невдомёк!

В случаях, когда необходимо изменить или сохранить данные на сервере, отправляют
POST-запросы.

Это происходит при регистрации на каком-либо сайте (ваши данные будут сохранены
на сервере) или при создании / редактировании сообщения в соцсетях (сообщение
будет сохранено или изменено на сервере).

Посредством POST-запросов можно передавать любые данные. Например, при заказе
товара в интернет-магазине ваше имя и адрес доставки будут отправлены как текст,
количество заказанных товаров — как число, а картинка-схема «куда доставить
товар» — как файл.

Форма Первиса Эсли

Чтобы дать пользователю возможность отправлять на сервер данные прямо с
веб-страницы, в HTML есть элемент Form, «веб-форма», он обозначается парным
тегом <form>.

На несуществующем сайте Первиса Эсли есть форма регистрации. Пользователи создают
учётные записи, затем авторизуются и бурно обсуждают на форуме исключительные
достоинства Первиса.

Передача на сервер регистрационных данных — самый типичный случай отправки
POST-запроса. Форма регистрации выглядит так:

скрин_1.jpg

HTML-код этой формы:

	<!-- в форме пять интерактивных элементов input: 
	два поля для ввода текста,
	пара связанных между собой кнопок radio button
	и кнопка отправки запроса -->

	<!-- начало формы; 
	указано, какой метод применять при отправке: POST 
	и на какой адрес отправить запрос: /registration/ -->
	<form method="post" action="/registration/">
		<!-- label — это заголовок для поля формы -->
		  <label>Имя</label>
		<!-- Аргумент required может применяться к любому полю ввода.
		Он означает, что поле обязательно для заполнения. 
		Если поле не заполнено — браузер не отправит форму -->
		  <input type="text" required name="login"><!-- поле ввода логина -->
		  <label>Электропочта</label>
		  <input type="email" required name="mail"><!-- поле ввода почтового адреса -->
		<!-- набор radio button, кнопок для выбора одного варианта из нескольких -->
		  <input type="radio" required name="relation" value="like">Люблю Первиса<br>
		  <input type="radio" required name="relation" value="dislike">Терпеть ненавижу Первиса<br>
		<!-- ...и кнопка отправки -->
		<input type="submit" value="Регистрируюсь!">
	<!-- конец формы: закрывающий тег-->
	</form>

Открывающий тег <form> содержит техническую информацию:

    каким методом отправить запрос: method="post",
    по какому URL этот запрос должен быть отправлен: action="/registration/".

Тег <form> не отрисовывается на веб-странице, он лишь определяет начало и конец
кода формы.

При отправке этой формы браузер отправит на сервер POST-запрос — текст в
определённом формате

	POST /registration/ HTTP/1.0
	...
	login=Greatestfan&mail=greatestfan@yandex-team.ru&relation=like
 
    В первой строке запроса — название метода, здесь это POST.
    Далее указан URL, по которому отправлен запрос — /registration/.
    Завершает первую строчку версия протокола — HTTP/1.0.

Отправленные через форму данные приходят на сервер в виде пар «имя=значение».
Таких пар может быть много, друг от друга они отделены амперсандом &:

	login=Greatestfan
	&
	mail=greatestfan@yandex-team.ru
	&
	relation=like 

Имена полей (login, mail и relation) берутся из HTML-разметки формы, эти имена
задаёт разработчик:

	<input type="text" name="login"> <!-- имя задано в атрибуте name --> 

Значения полей — текст, который пользователь ввёл в поле (например, Greatestfan)
или предустановленное разработчиком значение value в случае с радио-кнопками.
Например, если пользователь выбрал кнопку, в коде которой написано
name="relation" value="like", на сервер будет отправлено relation=like.

Объект request

Когда на сервер приходит запрос, Django извлекает из него всю информацию и в
структурированном виде помещает в объект request.

Объектом в языках программирования называют сущность, имеющую имя и набор свойств.
Каждое свойство имеет своё имя (ключ) и значение, точно как в словаре.

Объект request передаётся в обязательном аргументе во view-функцию:

	def index(request):
		# какой-то код
		# здесь можно получить данные запроса из объекта request 

Чтобы узнать тип полученного запроса — нужно обратиться к свойству method
объекта request:

	def index(request):
		print(request.method) # будет напечатано: POST 

Объект request содержит в упорядоченном виде всю информацию, полученную в
запросе: IP-адрес пользователя, его cookies и информацию о его браузере,
данные о том, с какого URL пользователь отправил запрос и к какому URL
обратился — и много всего другого. О том, какие ещё данные хранятся в request,
можно прочесть в официальной документации Django.
(https://docs.djangoproject.com/en/2.2/ref/request-response/)

Информация, переданная из веб-формы, хранится в словаре request.POST
(или в request.GET, в зависимости от типа запроса).

И её можно извлечь.

	# В POST-запросе на сервер переданы 
	# логин пользователя, его email и его отношение к Первису.
	# Django сложил всю эту информацию в словарь request.POST
	{
		'login' : 'Greatestfan',
		'mail' : 'greatestfan@yandex-team.ru',
		'relation' : 'like',
	} 

Теперь с этими данными можно работать как с обычным словарём:

	# view-функция узнаёт тип запроса 
	# и достаёт из свойства request.POST данные пользователя:
	def index(request):
		if request.method == 'POST':
			form_login = request.POST['login']  # form_login = 'Greatestfan'
			form_mail = request.POST['mail']  # form_mail = 'greatestfan@yandex-team.ru'
			form_relation = request.POST['relation']  # form_relation = 'like' 

Данные из запроса можно обрабатывать как угодно: сохранить их в базе данных,
вывести на страницу или пересчитать число символов в логине и адресе.

И, конечно, можно отправить письмо с отказом в регистрации тому пользователю,
который в поле relation посмел установить значение dislike.

Пришло время сделать всё по-настоящему: отправить через форму данные на сервер,
обработать запрос и вернуть нужный ответ.

В проекте Anfisa4friends из формы будет отправляться POST-запрос к главной
странице.

Вы напишете такой код, чтобы запросы к главной странице обрабатывались по-разному,
в зависимости от типа запроса:

    В ответ на GET-запрос вернётся страница с формой.
    
	При POST-запросе на страницу в дополнение к форме будут выведены результаты
	обработки данных из запроса.

===============================================================================
Тренажер - проект

Задача 1/3:

View-функция index() в приложении homepage изменена: теперь каждое имя в списке
друзей сопровождается HTML-элементом radio button: <input type="radio">.
Допишите код так, чтобы:

    Приложение homepage выводило форму с возможностью выбрать одного из друзей
	и отправить имя этого друга POST-запросом на URL главной страницы.
    
	По POST-запросу из формы приложение homepage возвращало информацию
	о городе проживания запрошенного друга и о погоде в его городе.

Во view-функции index() приложения homepage проверьте тип запроса, и если
пришёл запрос POST — обработайте его:

    Из запроса получите имя друга и запишите его в переменную selected_friend.
    
	Обратитесь к списку друзей и узнайте город, где живёт запрошенный друг.
	Запишите название этого города в переменную city.
    
	Передайте название города в функцию what_weather() из anfisa.services.
	Функция вернёт погоду в этом городе, запишите её в переменную weather.
    
	В переменную friend_output запишите фразу {Имя_друга}, тебе прислали мороженое!
    
	В переменную city_weather запишите фразу Погода в городе {название_города}:
	{погода_в_городе}.
    
	Вместо слов в фигурных скобках должны быть реальные данные: имя,
	название города и строка с погодой.
    
	Передайте переменные friend_output и city_weather в словарь context.

Подсказка:

    Имя друга можно получить из словаря request.POST по ключу ['friend']
    
	Имя друга — это ключ в списке friends_db, а название города — значение
	этого ключа. Так что переменной city нужно присвоить значение
	friends_db[selected_friend]
    
	Название города city должно быть передано аргументом в функцию
	what_weather(). Результат работы функции записываем в переменную weather:
	weather = what_weather(city)

Проект в папке project_3_1

Задача 2/3:

Теперь подготовьте шаблон главной страницы: добавьте в него форму и подготовьте
вывод ответа:

    В шаблоне templates/homepage/index.html в теге form укажите атрибуты:
        URL, на который форма должна отправить запрос (URL главной страницы)
        Тип запроса, который должна отправить форма (POST)
    В шаблоне templates/homepage/index.html между тегами <form> и </form> выведите
	переменную friends из словаря context.
    
	В форме после переменной friends добавьте кнопку отправки формы с надписью
	«Узнать город и погоду»
    
	Выведите переменные friend_output и city_weather в шаблон главной страницы.
	Теперь, если из формы отправлено имя «Коля», на страницу должно быть выведено:
    
	Коля, тебе прислали мороженое!
    Погода в городе Красноярск: 🌩 🌡️+16°C 🌬️→26km/h

Подсказка:

    Впишите в тег <form> аргументы action="/" и method="post".
    Вывод переменной в шаблон выглядит так: {{ имя_переменной }}
    Переменную friends выведите между тегами <form> и </form>
    HTML-код кнопки для отправки формы: <input type="submit"
	value="Надпись на кнопке">
    Переменные friend_output и city_weather выведите в шаблон перед тегом <form>.
	Каждая из переменных должна быть обёрнута тегом <p>.

Проект в папке project_3_2

Задача 3/3:

Перенесите в форму список сортов мороженого, чтобы на сервер можно было
одновременно отправить имя друга и название мороженого.

Во view-функции index() приложения homepage (homepage/views.py):

    Исправьте цикл, который выводит список мороженого: допишите код так,
	чтобы перед каждым названием мороженого вставлялась радио-кнопка
	<input type="radio" name="icecream" required value="название_мороженого">
	(вместо название_мороженого должны вставляться реальные названия мороженого
	из icecream_db).
    
	Полученное в запросе название мороженого запишите в переменную
	selected_icecream.
    
	Измените строку friend_output: вместо слова «мороженое» подставьте
	название мороженого из запроса. Должно получиться так:
    
	{Имядруга}, тебе прислали {названиемороженого}!

В шаблоне templates/homepage/index.html:

    Выведите в шаблон список сортов мороженого с радио-кнопками.
    
	Измените надпись на кнопке отправки формы: задача изменилась, пусть теперь
	там будет написано «Угостить».

Подсказка:

    Код добавления радио-кнопки можно подсмотреть в цикле, который выводит
	список друзей. Обязательно поменяйте атрибуты name и value .
    
	Значением атрибута value должно быть название мороженого. Название можно
	получить так: icecream_db[i]["name"].
    
	Название мороженого из запроса можно получить из словаря request.POST
	по ключу ['icecream'].
    
	Вместо слова «мороженое» в строку f'{selected_friend}, тебе прислали
	мороженое' вставьте значение переменной {selected_icecream}.

Проект в папке project_3_3
===============================================================================
