Форматирование времени

До сих пор вы печатали время только в одном формате.

	import datetime as dt


	arrival_time = dt.datetime(2019, 5, 10, 19, 45)
		
	print('Самолёт прибывает в', arrival_time) 

	Самолёт прибывает в 2019-05-10 19:45:00 

Что делать, если хочется напечатать сообщение по-человечески, скажем:
Сейчас 10:31? Для этого существует метод strftime(). Его можно применить
к любому объекту типа datetime и аргументом задать формат вывода времени:

	print('Самолёт прибывает в', arrival_time.strftime('%H:%M')) 

	Самолёт прибывает в 19:45 

Здесь %H означает часы, %M — минуты.

Кроме этих параметров, бывают ещё, например %B — месяц, %Y — год и %S — секунды,
%A — название дня недели по-английски, %U — номер недели в году.

	import datetime as dt


	# дата первого осеннего снега в Новосибирске в 2018
	first_snow = dt.datetime(2018, 9, 9)

	# дата последнего весеннего снега в Новосибирске в 2018
	last_snow = dt.datetime(2018, 5, 19)

	print(last_snow.strftime('Последний снег выпал в %U-ю неделю года.'))
	print(first_snow.strftime('А первый снег пошёл в %U-ю неделю.'))

	Последний снег выпал в 19-ю неделю года.
	А первый снег пошёл в 36-ю неделю.

В 2018 году новосибирцы прожили без снега целых 17 недель!

===============================================================================
Тренажер

Задача 1/2:

Сделайте так, чтобы функция what_time() возвращала время в формате часы:минуты.

Подсказка:

К тому, что раньше возвращала функция, нужно применить метод .strftime()
с форматом строки %H:%M. Возможно, для этого возвращаемое значение удобно
записать в отдельную переменную.

******************************************
	import datetime as dt


	DATABASE = {
		'Серёга': 'Омск',
		'Соня': 'Москва',
		'Дима': 'Челябинск',
		'Алина': 'Красноярск',
		'Егор': 'Пермь'
	}

	UTC_OFFSET = {
		'Санкт-Петербург': 3,
		'Москва': 3,
		'Самара': 4,
		'Новосибирск': 7,
		'Екатеринбург': 5,
		'Нижний Новгород': 3,
		'Казань': 3,
		'Челябинск': 5,
		'Омск': 6,
		'Ростов-на-Дону': 3,
		'Уфа': 5,
		'Красноярск': 7,
		'Пермь': 5,
		'Воронеж': 3,
		'Волгоград': 4,
		'Краснодар': 3,
		'Калининград': 2
	}


	def what_time(friend):
		# напишите код тела функции
		# пусть она вернет время у друга из аргумента friend
		now = dt.datetime.utcnow()
		delta_hours = UTC_OFFSET[DATABASE[friend]]
		curent_now = now + dt.timedelta(hours = delta_hours)
		return curent_now.strftime('%H:%M')

	print(what_time('Алина'))
******************************************

Задача 2/2:

Примените все полученные в этой теме знания, чтобы научить Анфису отвечать
на вопросы про друзей, сколько у них сейчас времени:

    Артём, который час?
    Антон, который час?

Примеры таких запросов уже добавлены в список queries в функции runner().

    Измените функцию process_friend(), чтобы она обрабатывала ещё один запрос,
	а именно query == 'который час?'
    
	Если город друга есть в базе UTC_OFFSET, вызовите функцию what_time() и,
	подставив полученный результат, верните ответ в формате Там сейчас 19:28.
    
	Если город отсутствует в базе UTC_OFFSET, то верните сообщение об ошибке
	<не могу определить время в городе {название}>

Подсказка:

В код функции process_friend() добавьте ещё один вариант:
elif query == 'который час?':

******************************************
	# подключите библиотеку datetime под именем dt
	import datetime as dt

	DATABASE = {
		'Сергей': 'Омск',
		'Соня': 'Москва',
		'Алексей': 'Калининград',
		'Миша': 'Москва',
		'Дима': 'Челябинск',
		'Алина': 'Красноярск',
		'Егор': 'Пермь',
		'Коля': 'Красноярск',
		'Артём': 'Владивосток',
		'Петя': 'Михайловка'
	}

	UTC_OFFSET = {
		'Москва': 3,
		'Санкт-Петербург': 3,
		'Новосибирск': 7,
		'Екатеринбург': 5,
		'Нижний Новгород': 3,
		'Казань': 3,
		'Челябинск': 5,
		'Омск': 6,
		'Самара': 4,
		'Ростов-на-Дону': 3,
		'Уфа': 5,
		'Красноярск': 7,
		'Воронеж': 3,
		'Пермь': 5,
		'Волгоград': 4,
		'Краснодар': 3,
		'Калининград': 2,
		'Владивосток': 10
	}


	def format_count_friends(count_friends):
		if count_friends == 1:
			return '1 друг'
		elif 2 <= count_friends <= 4:
			return f'{count_friends} друга'
		else:
			return f'{count_friends} друзей'


	def what_time(city):
		offset = UTC_OFFSET[city]
		city_time = dt.datetime.utcnow() + dt.timedelta(hours=offset)
		f_time = city_time.strftime("%H:%M")
		return f_time


	def process_anfisa(query):
		if query == 'сколько у меня друзей?':
			count_string = format_count_friends(len(DATABASE))
			return f'У тебя {count_string}'
		elif query == 'кто все мои друзья?':
			friends_string = ', '.join(DATABASE.keys())
			return f'Твои друзья: {friends_string}'
		elif query == 'где все мои друзья?':
			unique_cities = set(DATABASE.values())
			cities_string = ', '.join(unique_cities)
			return f'Твои друзья в городах: {cities_string}'
		else:
			return '<неизвестный запрос>'


	def process_friend(name, query):
		if name in DATABASE:
			city = DATABASE[name]
			if query == 'ты где?':
				return f'{name} в городе {city}'
			elif query == 'который час?':
				if city in UTC_OFFSET:
					time = what_time(city)
					return f'Там сейчас {time}'
				else:
					return f'<не могу определить время в городе {city}>'
			else:
				return '<неизвестный запрос>'
		else:
			return f'У тебя нет друга по имени {name}'


	def process_query(query):
		tokens = query.split(', ')
		name = tokens[0]
		if name == 'Анфиса':
			return process_anfisa(tokens[1])
		else:
			return process_friend(name, tokens[1])


	def runner():
		queries = [
			'Анфиса, сколько у меня друзей?',
			'Анфиса, кто все мои друзья?',
			'Анфиса, где все мои друзья?',
			'Анфиса, кто виноват?',
			'Коля, ты где?',
			'Соня, что делать?',
			'Антон, ты где?',
			'Алексей, который час?',
			'Артём, который час?',
			'Антон, который час?',
			'Петя, который час?'
		]
		for query in queries:
			print(query, '-', process_query(query))


	runner()
******************************************
===============================================================================
