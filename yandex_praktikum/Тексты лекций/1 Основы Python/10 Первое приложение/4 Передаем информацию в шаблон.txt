Передаем информацию в шаблон

Система шаблонов подключена, и теперь схема работы Django-проекта изменится:

    Сайт получил запрос от клиента.
    Проверил запрошенный URL по urls.py.
    Вызвал соответствующую запросу view-функцию.
    View-функция подготовила данные для ответа.
    View-функция передала подготовленные данные в HTML-шаблон.
    На основе шаблона и подготовленных данных компонуется код HTML-страницы.
    Готовый HTML-код страницы отправляется пользователю и отображается в его браузере.
    Всё!

Чтобы создать возвращаемую страницу, собрав воедино данные и шаблон, во 
view-функциях Django применяют функцию render() (англ. «визуализация»).

Теперь не нужно создавать в коде объект HttpResponse и передавать в него код
страницы, как вы это делали раньше. Эту задачу возьмёт на себя функция render():
она вернёт объект HttpResponse, который содержит код HTML-страницы,
собранной из HTML-кода шаблона и данных, переданных из view-функции.

В HTML-коде могут быть тысячи строк, но этот код будет храниться в отдельном
файле и не будет загромождать файлы с кодом на питоне.

Функция render() получает на вход переменную request (в request хранится вся
информация, полученная в запросе), имя HTML-шаблона и словарь (dict)
с информацией, которую надо поместить в шаблон. Этот словарь традиционно
называют context (англ. «смысл»)

	render(request, 'template.html', context) 

Функция render() возвращает объект HttpResponse, в который передан код
HTML-страницы, «собранной из деталей».

Всё это происходит «под капотом», и в результате код view-функции не раздувается
от HTML-разметки.

Теперь:

    view-функция подготавливает информацию (получает и обрабатывает данные,
	выполняет какие-то расчёты) и собирает её в словарь; обычно этот словарь
	называют context (англ. «смысл»);
    
	view-функция передает полученный от клиента запрос, путь к HTML-шаблону
	и словарь context в функцию render();
    
	render() размещает информацию из context в HTML-шаблоне и возвращает
	во view-функцию объект HttpResponse, содержащий скомпонованный код страницы;
    
	view-функция возвращает клиенту объект HttpResponse с красивой HTML-страницей.

скрин_11.jpg

Лучше сто раз увидеть, чем сто раз услышать.
Изменим view-функцию, которая управляет содержимым главной страницы:

    подготовим заголовок, сегодняшнюю дату, фрагмент текста;
    упакуем всё это в HTML-шаблон и вернём пользователю.

	# view-функция из файла homepage/views.py

	import datetime

	def homepage(request):
		# получить сегодняшнюю дату и вывести её в привычном формате: 
		#день.месяц.год
		current_date = datetime.date.today().strftime('%d.%m.%Y')

		# собрать в словарь context
		# все данные, которые надо отправить в HTML-шаблон
		context = {
		'title': 'Анфиса для друзей',    
		'date': current_date,
		'main_text': ('Скоро здесь будет отличный icecream-сервис,<br>'
				'который изменит интернет<br><strong>навсегда</strong>'),
		}

		# вызвать функцию render, чтобы она 
		# вставила в шаблон templates/homepage/homepage.html
		# данные из словаря context;
		# вернуть получившуюся страницу пользователю
		return render(request, 'homepage/homepage.html', context) 

Функция render() разместит в шаблоне данные из словаря context. В тех местах
шаблона, куда нужно вставить данные, указывают ключ, значение которого нужно
вывести.

Ключи пишутся в двойных фигурных скобках.

	<!-- файл templates/homepage/homepage.html -->
	<!DOCTYPE html>
	<html> 
	  <head>    
		<meta charset="UTF-8">  
	  </head>
	  <body>
		<h1>{{ title }}</h1>
		<h2>Сегодня {{ date }}</h2>
		<p>{{ main_text }}</p> 
	  </body>
	</html> 

В результате пользователь получит такую страницу:

скрин_12.jpg

Сработало: данные из словаря context выведены в шаблон.

Почти хорошо, но нехорошо: почему-то HTML-теги в элементе main_text оказались
на виду (вместо того, чтобы незаметно отформатировать текст).

Дело в том, что все HTML-теги, которые встречаются в значениях словаря context,
Django выводит в шаблон в виде текста. Такой вывод называют экранированием тегов.

Иногда это полезно, но явно не в нашем случае. Чтобы привести ситуацию в норму
— применим к выводу main_text опцию safe (дополнительные опции указываются
в шаблонах через символ | после ключа словаря). Эта опция указывает, что
HTML-теги в этом элементе должны быть выведены не текстом, а тегами.

	<!-- файл templates/homepage/homepage.html -->
	<!DOCTYPE html>
	<html> 
	  <head>    
		<meta charset="UTF-8">  
	  </head>
	  <body>
		<h1>{{ title }}</h1>
		<h2>Сегодня {{ date }}</h2>
		<!-- починили вывод HTML-тегов, добавили опцию safe -->
		<p>{{ main_text|safe }}</p> 
	  </body>
	</html> 

Проверяем, и что видим? Всё работает!

скрин_13.jpg

Код получившейся страницы будет таким:

	<!DOCTYPE html>
	<html> 
	  <head>
		<meta charset="UTF-8">  
	  </head>
	  <body>
		<h1>Анфиса для друзей</h1>
		<h2>Сегодня 30.02.2019</h2>
		<p>Скоро здесь будет отличный icecream-сервис,<br>который изменит интернет<br><strong>навсегда</strong></p> 
	  </body>
	</html> 

Перед тем, как вы приступите к заданиям — важное сообщение: в функции render()
обязательны только два аргумента: request и адрес HTML-шаблона.

Словарь с данными передавать не обязательно. Если он не передан — пользователю
будет отправлена страница с HTML-кодом шаблона.

===============================================================================
Тренажер - проект

Задача 1/2:

HTML-страницы, которые вы сверстали в прошлом задании, не пропали бесследно:
они перенесены в проект Anfisa4friends и стали HTML-шаблонами.

Файл index.html сохранен в директории templates/homepage.

Первая задача — вернуть index.html в ответ на запрос к главной странице.
Для этого понадобится функция render().

    В файл homepage/views.py импортируйте функцию render() из модуля
	django.shortcuts
    
	Импорт HttpResponse в этом файле теперь не нужен. Уберите его: код 
	станет легче, а система не будет делать ненужной работы.
    
	В файле homepage/views.py из view-функции вместо
	HttpResponse('Анфиса для друзей') верните функцию render(),
	передав ей два аргумента: объект request и адрес шаблона index.html
    
	В шаблоне index.html исправьте адрес ссылки: она должна вести на
	/icecream/ — ведь список мороженого в anfisa4friends расположен
	именно по этому адресу, а в шаблоне остался артефакт: ссылка
	на icecream-list.html

Подсказка:

    Строка импорта должна выглядеть так: from django.shortcuts import render
    
	View-функция должна вернуть результат работы функции render(). Инструкция
	должна выглядеть так: return render(аргументы)
    
	В функцию render() должны быть переданы два параметра: объект request
	и строка 'homepage/index.html'. Словарь context в этой ситуации не нужен.
    
	В шаблоне используйте относительную ссылку, не забудьте поставить '/' в
	конце адреса.

Проект в папке project_4_1

Задача 2/2:

Теперь сделайте так, чтобы при обращении к адресу icecream/ пользователю
возвращалась не скучная текстовая строка, а полноценная HTML-страница с
построчно разбитым списком мороженого.

View-функция icecream_list() должна возвращать функцию render(), в которую
будут переданы объект request, HTML-шаблон icecream-list.html и словарь context,
в котором будет храниться заранее созданный и отформатированный список сортов
мороженого.

    В файле icecream/views.py измените view-функцию icecream_list() так, 
	чтобы она выводила названия мороженого построчно; разделитель :: удалите
	из кода. Должно получиться так:
    
	Золотое мороженое
    
	Готическое мороженое
    
	...
    
	Томатное мороженое
    
	Этого можно добиться с помощью HTML.
    
	Создайте словарь context и сохраните в него получившуюся строку под
	ключом icecreams. Словарь context потом отправится в функцию render().
    
	Как и в предыдущем задании, импортируйте функцию render() из django.shortcuts;
	удалите импорт HttpResponse, он уже не нужен, render всё сделает за него.
    
	Вместо объекта HttpResponse верните из view-функции icecream_list() результат
	выполнения функции render().
    
	В неё передайте объект request, адрес шаблона icecream/icecream-list.html
	и словарь context: из него список мороженого будет выведен в шаблон.
    
	В шаблоне templates/icecream/icecream-list.html удалите статичный список
	мороженого и выведите список сортов из словаря context.
    
	В том же HTML-шаблоне исправьте адрес ссылки на главную страницу: она должна
	вести на адрес "/".

Подсказка:

Если вместо разделителя :: поставить <br> — каждое название будет стоять
на отдельной строке.

Создайте словарь context и в элемент с ключом 'icecreams' запишите переменную
icecreams : context = {'icecreams': icecreams,}

Как вернуть из view-функции функцию render? Вот так:
return render(аргументы-аргументы-аргументы)

Если HTML-теги из списка сортов мороженого оказались видны на странице
— значит, при выводе в шаблон для {{ icecreams }} не указана опция | safe.

Проект в папке project_4_2
===============================================================================
