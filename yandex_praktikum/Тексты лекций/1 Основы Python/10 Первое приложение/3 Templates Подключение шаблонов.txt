Templates. Подключение шаблонов

Теперь, когда вы знаете, что такое HTML и для чего он нужен, внутренняя логика
обработки запросов в Django приобрела завершённый вид.

    Сервер получил запрос от клиента
    Проверил запрошенный URL по urls.py
    Вызвал соответствующую запросу view-функцию
    View-функция подготовила информацию и в виде строки с HTML отправила её клиенту
    Всё!

скрин_10.jpg

View-функция главной страницы проекта сейчас такая:

	#  файл homepage/views.py

	def index(request):
		# здесь можно провести какие-нибудь вычисления
		# или запросить информацию из файла models.py
		# ...
		# и после обработки отправить полученные данные пользователю
		return HttpResponse('Anfisa for Friends -- Hello, world! -- ¯\(°:°)/¯') 

На вход функция получила данные запроса в аргументе request, а вернула объект
HttpResponse, в который передана строка с ответом. И эту строку нужно обернуть
в HTML, отформатировать.

Если таким способом вернуть пользователю самую простую HTML-страницу, в которой
есть только необходимые теги и заголовок, получится нечитаемая строка:

	#  файл homepage/views.py

	def index(request):
		return HttpResponse('<!DOCTYPE html><html><head></head><body><h1>Anfisa for Friends -- Hello, world! -- ¯\(°:°)/¯</h1></body></html>') 

Код HTML-страницы может состоять из сотен строк, и если размещать его прямо
во view-функции — получится ужасный винегрет из Python и HTML, работать с ним
будет невозможно.

Чтобы решить эту проблему, HTML-код выносят в отдельные файлы, а в них передают
данные, подготовленные view-функцией; после такой «сборки» готовую страницу
отправляют пользователю.

Разработчик создаёт заготовки HTML-страниц, в которые можно передать данные
из view-функции. Такие заготовки страниц называются HTML-шаблоны.

По своей сути шаблоны похожи на упаковочные коробки: в них можно «положить»
любую информацию, и содержимое будет выглядеть нарядно, будь то конфеты,
болтики или белые мыши.

Django любит порядок. Данные хранятся отдельно, списки URL — отдельно,
view-функции — отдельно. При такой структуре становится удобно работать 
с каждым из элементов. То же и с HTML-файлами: их хранят отдельно
от остального кода.

Шаблоны на практике

В корне проекта создана папка templates, а в ней, в директориях приложений,
сохранены сами шаблоны, HTML-файлы. Это распространенная практика размещения
шаблонов в Django.

	├── anfisa4freinds 
	│   ├── settings.py
	│   └── urls.py
	├── icecream
	│   ├── models.py  
	│   ├── views.py
	│   └── urls.py
	├── homepage
	│   ├── views.py
	│   └── urls.py
	├── templates  # склад шаблонов
	│   ├── icecream
	│   │   └── icecream-list.html   
	│   └── homepage
	│       └── index.html
	└── manage.py
 

В Django входит инструмент для работы с шаблонами: DjangoTemplates. Он уже
подключен в конфиге, в константе TEMPLATES.

	import os
	# импортируем стандартную библиотеку для работы с файлами. 
	# это даст возможность указать расположение папок и файлов на компьютере

	...

	# указываем корневую папку проекта
	BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
	 
	TEMPLATES = [
		{
			# здесь подключена система управления шаблонами DjangoTemplates
			'BACKEND': 'django.template.backends.django.DjangoTemplates',
			# указываем, где система должна искать шаблоны: 
			  # в папке templates корневой директории проекта
			'DIRS': [os.path.join(BASE_DIR, 'templates')],  
			'APP_DIRS': True,
			'OPTIONS': {
				'context_processors': [
					'django.template.context_processors.debug',
					'django.template.context_processors.request',
					'django.contrib.auth.context_processors.auth',
					'django.contrib.messages.context_processors.messages',
				],
			},
		},
	]
	... 

Когда в коде необходимо указать адрес какого-то шаблона — адрес отсчитывается
от директории, указанной в константе TEMPLATES под ключом DIRS.

В проекте Anfisa4friends отсчёт будет вестись от директории templates/ в корне
проекта, так что в коде нужно указывать адрес homepage/index.html,
а не templates/homepage/index.html
