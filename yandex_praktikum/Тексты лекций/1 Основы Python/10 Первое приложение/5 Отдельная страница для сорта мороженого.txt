Отдельная страница для сорта мороженого

Проект растёт. Список сортов мороженого из базы данных выложен на страницу
icecream/, пора сделать страницы для каждого мороженого, где будет выводиться
полное описание этого сорта. Задача в общем виде стоит такая: взять из базы
данных одну запись и вывести на отдельную страницу информацию из этой записи.

Почему бы не подсмотреть, как сходную задачу решили на воображаемом сайте
вымышленного исполнителя?

Show Me My Hit!

На своём воображаемом сайте Первис Эсли выложил коллекцию своих любимых дисков:
это его альбомы, изданные с 1975 по 1977 год. Он ценит истинное качество и потому
слушает только свои альбомы.

	albums_db = [
		'1975 | Real Gold',
		'1975 | Forever',
		'1975 | The Pervis Esli Shine Collection',
		'1975 | Triple Dynamite',
		'1976 | A Legendary Singer, Vol. 13',
		'1976 | The Rain Sessions',
		'1976 | From Pervis Esli Boulevard, Memphis, Tennessee',
		'1977 | Welcome To My Space',
		'1977 | Moody Pink',
		'1977 | Pervis In Concert',
	]

Структура проекта на сайте Первиса примерно такая же, как и в Anfisa4friends:

	...
	├── albums
	│   ├── models.py  
	│   ├── views.py
	│   └── urls.py
	├── templates
	│   ├── albums
	│   │   ├── album-detail.html  # шаблон для подробной информации об альбоме
	│   │   ├── 
	│   │    ...
	│   ...
	...
 
Посетитель сайта хочет получить информацию об альбоме, который записан в базе
под индексом 1. Посетитель, конечно, ничего не знает ни про список, ни про
индексы, но на странице сайта пользователю дали готовую ссылку:

	<a href="/album/1/">Альбом 1</a>
	<!-- единица в адресе — это как раз индекс альбома в списке album_db -->
	<!-- в базе не очень много информации, так что сохраним интригу и не будем давать в ссылке название альбома -->

Пользователь щёлкнул по ссылке, на сервер отправился запрос к URL /album/1/
и пошёл по инстанциям.

Сначала — в головной urls.py

	#  список urlpatterns из urls.py проекта
	...

	urlpatterns = [
		...
		#  если запрос начинается с '/album/' — 
		#  ищи правила обработки таких запросов в urls.py в директории /albums
		path('album/', include('albums.urls')),

	]

Оттуда — в urls.py приложения albums:

	# файл albums/urls.py

	urlpatterns = [
		#  функция album_detail_1 обрабатывает урл {URL}/album/1/
		path('1/', views.album_detail_1)
	] 

Вызывается функция album_detail_1()

	#albums/views.py
	...
	from .models import albums_db

	def album_detail_1(request):
		# получили из базы запись под индексом 1
		about_album = albums_db[1]
		# передали в словарь context
		context = {
			'about_album': about_album,        
		}
		# передали в render() и вернули пользователю
		return render(request, 'albums/album-detail.html', context)

В результате пользователь получает страницу с информацией об альбоме
с индексом 1: 1975 | Forever

Но в базе данных — десять альбомов, а когда Первис вернётся — прибавится
ещё сто. Писать для каждого альбома собственную view-функцию — нерационально
и трудоёмко.

Адреса страниц всех альбомов полностью идентичны, отличаются они лишь
последним аргументом — индексом запрашиваемого альбома. Как тут не вспомнить
про переменные.

В шаблон адреса в path() можно включать переменные. Они будут переданы
во view-функцию, и данные будут сформированы на их основе. При таком подходе
можно обойтись одним path(), одной view-функцией и одним шаблоном для всех альбомов.

	# albums/urls.py
	...
	urlpatterns = [
		# <int:pk> означает, что мы ждем переменную pk
		# типа int (целое число). 
		# теперь все URL вида album/какое_то_целое_число/
		# будут обрабатываться функцией album_detail()
		path('<int:pk>/', views.album_detail)
	]
	# имя pk произведено от английского primary key, «первичный ключ», 
	# это общепринятое имя для переменных, в которых передаётся индекс объекта 

Путь album/<int:pk>/ вызовет функцию album_detail() для всех однотипных адресов:
/album/1/
/album/2/
/album/3/
и даже для /album/100500/

Чтобы всё заработало — функция album_detail() должна принять на вход параметр pk:
название параметра должно быть таким же, как имя переменной в path().

	# передаём в функцию данные из запроса (request)
	# и переменную pk (в ней сохранён индекс альбома, 
	# информацию о котором хотим показать)
	def album_detail(request, pk):
		about_album = albums_db[pk]    
	   
		context = {
			'about_album': about_album,             
		}
		return render(request, 'albums/album-detail.html', context) 

Словарь context в элементе с ключом about_album хранит информацию об альбоме
с тем индексом, который был передан в URL.

Выведем данные в шаблон:

	<!-- templates/albums/album-detail.html -->
	...
	<h1>{{ about_album }}</h1>
	... 

В результате на сайте Первиса страница альбома с pk == 8 будет выглядеть так:

скрин_14.jpg

Анфиса тоже так может

Пора создать отдельные страницы для каждого сорта мороженого в проекте
Anfisa4friends. Для этого нужно:

    Придумать универсальный URL для этих страниц. Это зависит от фантазии
	разработчика и логики, которой он придерживается.
    
	Написать view-функцию для страницы.
    
	Создать HTML-шаблон страницы.

Адрес: фантазия разработчика подсказывает, что адреса вида 
icecream/индекс_мороженого/ будут понятны и логичны. Будем применять именно
такие адреса.

View-функция: прямо сейчас, в задании, вы напишете эту функцию в файле
/icecream/views.py

HTML-шаблон: этот файл вы подготовили в уроке по HTML, там было описание
золотого мороженого. Теперь этот файл перенесён в проект, в директорию
/icecream папки с шаблонами. Этот шаблон будет работать для всех сортов
мороженого, поэтому он переименован в icecream-detail.html

===============================================================================
Тренажер - проект

Задача 1/3:

    В файле icecream/urls.py создайте path(), обрабатывающий адреса вида 1/,
	100500/ и подобные им. Для таких адресов должна вызываться функция
	icecream_detail(). Переменная тут будет очень кстати.
    
	Файл icecream/urls.py подключен к основному urls.py через include,
	так что в нём обрабатывается только часть адреса.
    
	Сделайте так, чтобы view-функция icecream_detail() в файле icecream/views.py
	принимала переменную pk из path(), который вызывает эту функцию.
    
	Во view-функции icecream_detail() получите из списка icecream_db элемент
	с индексом pk и передайте в переменные name и description название мороженого
	и его описание.
    
	Функция icecream_detail() вернёт результат работы функции render(),
	в которую переданы объект request, путь к шаблону icecream-detail.html
	и словарь context.
    
	Выведите в HTML-шаблон templates/icecream/icecream-detail.html данные
	из словаря context.

Подсказка:

    В список urlpatterns файла icecream/urls.py добавьте ещё один элемент:
	path('<int:pk>/', views.icecream_detail).
    
	View-функция icecream_detail() должна получить на вход два параметра:
	обязательный параметр request и переменную pk.
    
	Достать из вложенного словаря содержимое по ключу можно так:
	icecream_db[индекс_записи]['имя_ключа'].
    
	Адрес шаблона в render() указывается относительно основной директории
	шаблонов, то есть не templates/icecream/icecream-detail.html,
	а icecream/icecream-detail.html.
    
	Для вывода данных из словаря context в шаблон ключи словаря указывают
	в двойных фигурных скобках: {{ имя_ключа }}. Этот вывод можно обрамлять
	в HTML-теги, например, так: <h1>{{ имя_ключа }}</h1>.

Проект в папке project_5_1

Задача 2/3:

Теперь создайте навигацию по сортам мороженого. На странице icecream/
превратите каждое название мороженого в ссылку, чтобы при клике по названию
можно было перейти на страницу с подробной информацией об этом мороженом.
Ссылки должны быть относительные. Измените функцию icecream_list() в файле
icecream/views.py.

В результате должен получиться такой HTML-код:

	<a href="0/">Золотое мороженое</a><br>
	<a href="1/">Готическое мороженое</a><br>
	<a href="2/">Мороженое паста карбонара</a><br>
	... 

Подсказка:

В цикле, который перебирает элементы из списка icecream_db и получает из него
названия мороженого, перед названием сорта вставьте открывающий HTML-тег <a>
с атрибутом href="индекс_элемента/", а после названия — закрывающий </a>.
Индекс элемента хранится в счётчике итераций цикла (в переменной i).
Обратите внимание, что ссылка во view-функции должна быть вида
href="индекс_элемента/", поскольку мы используем относительную ссылку из файла
с адресом icecream/.

После каждого элемента должен стоять тег <br>, иначе будет не построчный вывод
названий, а слипшаяся строка.

Проект в папке project_5_2

Задача 2/3:

Найдите информацию о каком-нибудь ещё странном сорте мороженого, одном или
нескольких, добавьте их в список icecream_db и посмотрите, как будет выглядеть
страница {URL}/icecream/ и страницы с описанием новых сортов.

Для разнообразия можно сделать несложную вёрстку в тексте описания мороженого:
оформить какие-то слова жирным шрифтом (парный тег <strong>) или курсивом
(парный тег <i>).

Вёрстка не обязательна, главное — добавить в список новые сорта мороженого
и убедиться, что всё работает.

Подсказка:

В список icecream_db добавьте новый словарь:
{'name': 'Новое название',  'description': 'Описание'}. Не забудьте запятую.

Длинное описание лучше побить на короткие строки, как это сделано в других
пунктах списка.

Проект в папке project_5_3
===============================================================================
