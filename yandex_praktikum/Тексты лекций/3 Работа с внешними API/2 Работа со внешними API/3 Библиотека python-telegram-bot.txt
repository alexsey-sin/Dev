Библиотека python-telegram-bot

Для работы с Bot API есть четыре популярные Python-библиотеки:

    python-telegram-bot (https://github.com/python-telegram-bot/python-telegram-bot)
    pyTelegramBotAPI (https://github.com/eternnoir/pyTelegramBotAPI)
    AIOGram (https://github.com/aiogram/aiogram)
    telethon (https://github.com/LonamiWebs/Telethon)

Поработаем с python-telegram-bot. Это популярная библиотека с удобным интерфейсом:
методы классов совпадают с названиями методов Bot API.
В python-telegram-bot все методы Bot API вызываются как методы различных классов
библиотеки.

Библиотека разделена на три пакета: 

    telegram — основной пакет, содержит все методы Bot API, перенесённые на Python.
    telegram.ext — вспомогательный пакет, он содержит методы-обёртки для стандартных
		методов Bot API, позволяет упростить код и убирает рутинные операции
		«под капот», примерно так же, как это происходит во фреймворках.
    telegram.utils — пакет для продвинутой работы с библиотекой, позволяет
		низкоуровнево переопределять и расширять библиотеку.

Пакеты python-telegram-bot импортируются в код под именем telegram (это неожиданно,
но это так):

	import telegram

	# Здесь будет код Телеграм-бота

Или так:
	import telegram.ext

	# Здесь будет код Телеграм-бота

Bot API vs PEP8

В официальный документации Bot API все методы описаны в camelCase, но это не
питонично, поэтому разработчики библиотеки python-telegram-bot продублировали
названия методов в snake_case.

Это значит, что метод sendMessage может быть вызван так: telegram.Bot.sendMessage
или так: telegram.Bot.send_message. Лучше соблюдать PEP8 и писать в стиле snake_case.
Библиотека
Для стандартных задач в библиотеке python-telegram-bot есть готовые решения:

    отправка/получение сообщений;
    обработка «команд» — сообщений со слешем, вроде /start или /help;
    создание кнопок;
    запись в базу (долговременное хранение сообщений).

Решение всех этих задач реализовано на классах.
Создайте новый проект в директории /tg_bot, установите виртуальное окружение
и библиотеку python-telegram-bot.

	mkdir tg_bot # Создаём директорию
	cd tg_bot # Переходим в эту директорию
	python3 -m venv venv  # Создаём виртуальное окружение
	. venv/bin/activate  # Активируем виртуальное окружение
	pip3 install python-telegram-bot  # Устанавливаем библиотеку

Класс Bot()

Этот класс реализует методы API, связанные с отправкой, редактированием,
пересылкой или удалением сообщений и прочими активными действиями бота,
не связанными с получением и обработкой входящих сообщений.

Например, на основе класса Bot можно написать бота-администратора, который
будет удалять из группового чата сообщения с неприличными словами и отправлять
уведомления авторам удалённых сообщений.

В начале работы создаётся экземпляр этого класса и в него передаётся токен.
После этого можно работать с методами класса: 

	from telegram import Bot

	bot = Bot(token=TOKEN)
	# Отправка сообщения
	chat_id = 123456
	text = 'Вам телеграмма!'
	bot.send_message(chat_id, text)

В рабочем приложении из соображений безопасности токен следует хранить в
переменных окружения.

Запустите этот код: подставьте в него свой chat_id, токен сохраните в виртуальном
окружении, передайте его в код и отправьте сообщение.

Документация по классу Bot().
(https://python-telegram-bot.readthedocs.io/en/stable/telegram.bot.html)

Класс Updater()

Этот класс предназначен для получения и обработки входящих сообщений.
При создании объекта класса Updater в него передаётся токен, точно так же,
как и в Bot:

	from telegram.ext import Updater

	updater = Updater(token=TOKEN)

Экземпляры классов Bot и Updater принимают на вход токен Телеграм-бота и могут
делать запросы от имени его аккаунта. Фактически экземпляры классов Bot и
Updater — это экземпляры бота.

Обработка входящих сообщений

Сообщения в Telegram делятся на типы: есть простые текстовые сообщения, есть
сообщения-картинки, сообщения-стикеры, сообщения-файлы. Каждый тип можно
обрабатывать по-разному: например, текстовые сообщения можно парсить и отвечать
на них текстовым сообщением, полученные картинки и файлы сохранять или пересылать,
а на стикеры отвечать стикерами.

Для обработки сообщений:

    Посредством диспетчера регистрируется класс-обработчик (для примера выбран
		обработчик MessageHandler):
    updater.dispatcher.add_handler(MessageHandler(...)).
    В обработчик передаются два параметра:
    updater.dispatcher.add_handler(MessageHandler(Filters.text, say_hi))
        Filters.text — фильтр, выбирающий из обновлений сообщения определённого
			типа (в приведённом примере будут выбраны только текстовые сообщения).
        say_hi() — функция, которая будет обрабатывать выбранные сообщения.
        В функцию передаются два аргумента:
        объект бота Updater (это экземпляр бота, в котором зарегистрирован
			обработчик);
        отфильтрованный список сообщений в объекте Update.
        Эти аргументы передаются неявно: в коде обработчика описывать эти
			аргументы не нужно, но вызываемая функция должна ожидать их:
			say_hi(bot, update).

	from telegram.ext import Updater, Filters, MessageHandler

	updater = Updater(token=TOKEN)

	def say_hi(bot, update):
		# В ответ на любое сообщение, переданное в аргумент update, 
		# будет отправлено сообщение 'Привет, я бот'
		bot.message.reply_text('Привет, я бот')

	# Регистрируется обработчик MessageHandler;
	# из всех полученных сообщений он будет выбирать только текстовые сообщения
	# и передавать их в функцию say_hi()
	updater.dispatcher.add_handler(MessageHandler(Filters.text, say_hi))

	# Метод start_polling() запускает процесс polling, 
	# приложение начнёт отправлять регулярные запросы для получения обновлений.
	updater.start_polling()

Метод start_polling отправляет регулярные запросы к серверу Telegram и проверяет
обновления. По умолчанию запросы отправляются каждые 10 секунд. Периодичность
опроса можно изменить, передав методу именованный параметр poll_interval и указав
нужный интервал запросов (в секундах, float):

	updater.start_polling(poll_interval=20.0)

Класс Filters()
Класс Filters() может отфильтровывать сообщения по типу

    Filters.text
    Filters.photo
    Filters.video
    Можно фильтровать по ID или имени отправителя, по типу чата
		(личный чат или канал) или по множеству других признаков.

Если требуется обработать все сообщения — применяют Filters.all.
Документация по фильтрам.
(https://python-telegram-bot.readthedocs.io/en/stable/telegram.ext.filters.html)

Handler() и Update()
Handler — общеупотребимый в программировании термин, он означает «обработчик».

В библиотеке python-telegram-bot есть множество готовых обработчиков для
разных задач.

Эти обработчики связывают список отфильтрованных по какому-то признаку сообщений
с функцией, которая должна этот список обработать.

Список сообщений хранится в объекте Update и передаётся в функцию вторым аргументом.
Первым аргументом в неё передаётся экземпляр бота.

Приведённый в примере обработчик MessageHandler фильтрует полученные сообщения
(выбирает только текстовые), сохраняет их в виде списка в объект Update — и этот
список сообщений обрабатывается в функции say_hi().
Чтобы посмотреть, в каком виде полученные сообщения хранятся в объекте Update :

    отправьте своему боту несколько сообщений;
    в листинге выше измените код функции say_hi() так, чтобы она вывела на печать
		объект Update, полученный во втором аргументе;
    запустите этот код в редакторе.

MessageHandler — один из самых популярных и универсальных обработчиков в библиотеке,
ведь чаще всего работа идёт именно с сообщениями.

Другой обработчик, CommandHandler, более специализирован: он предназначен для
обработки команд — сообщений, начинающихся со слеша /. Самые распространённые
команды — /start, /help, скорее всего, вы их уже использовали при общении с ботами.

CommandHandler выбирает из обновлений сообщения с командами, сохраняет их в объект
Update и обрабатывает эти сообщения в функции, указанной вторым аргументом в
обработчике. 

	from telegram.ext import Updater, CommandHandler

	updater = Updater(token=TOKEN)

	def wake_up(bot, update):
		# В ответ на команду будет отправлено сообщение 'Спасибо, что включили меня'
		bot.message.reply_text('Спасибо, что включили меня')

	# Регистрируется обработчик CommandHandler;
	# он будет отфильтровывать только сообщения с содержимым '/start'
	# и передавать их в функцию wake_up()
	updater.dispatcher.add_handler(CommandHandler('start', wake_up))

	updater.start_polling()

Обработать команды можно и через универсальный MessageHandler, отфильтровав
сообщения через Filters, но CommandHandler упростит эту задачу.

Библиотека содержит и множество других обработчиков для различных ситуаций.
(https://python-telegram-bot.readthedocs.io/en/stable/telegram.html#handlers)

===============================================================================
Задача:
Бот отправляет вам сообщение
Напишите функцию, которая принимает на вход текст сообщения и отправляет это
сообщение пользователю, затем отправьте сообщение «Привет, я ботик, у меня баги».

    Импортируйте пакеты библиотеки python-telegram-bot.
    Создайте экземпляр класса telegram.Bot, он будет интерфейсом между вашим
		кодом и Bot API.
    Вызовите в коде функцию send_message().

Порядок проверки кода
Отправьте через мобильный или настольный клиент сообщение своему боту.
Запустите код в тренажёре (кнопка «Выполнить код»).
Убедитесь, что вам пришло сообщение в Телеграм.

Если после выполнения заданий в тренажёре вы переживаете за сохранность токена
— отзовите его через @BotFather.

Подсказка:
Токен передаётся в конструктор класса Bot при создании экземпляра.
Импортируйте пакеты командой import telegram.
Для отправки сообщения нужен метод telegram.Bot.send_message.
(https://python-telegram-bot.readthedocs.io/en/stable/telegram.bot.html#telegram.Bot.send_message)
Передайте в него chat_id и text.

	TELEGRAM_TOKEN = '1790736632:AAGq16DCLzFepGxxq1CId7Cswugp4OE_ZNc'
	CHAT_ID = '1740645090'  # Укажите chat_id
	import telegram

	bot = telegram.Bot(token=TELEGRAM_TOKEN)


	def send_message(message):
		bot.send_message(chat_id=CHAT_ID, text=message)

	send_message('Привет, я ботик, у меня баги')
===============================================================================
