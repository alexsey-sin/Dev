CRUD для Yatube

Вы набили руку в тренажёре и теперь можете самостоятельно, с нуля, написать API
для реального Django-проекта. Но прежде — необходимая для выполнения задания теория.

Предустановленный класс для работы с моделями: Viewset

Viewset (по-русски пишут просто «вьюсет») — это view-класс, реализующий все
операции CRUD. Viewset может вернуть объект или список объектов, создать, изменить
или удалить объекты.

Во вьюсеты встроена обработка разных типов запросов, работа с сериализаторами
и моделями, возврат ошибок. Не нужно ничего придумывать и писать повторяющийся код:
всё работает «из коробки».

Чтобы изменить стандартное поведение методов вьюсета — достаточно в классе-наследнике
переопределить нужный метод и внести в него необходимые изменения.

Для работы с вьюсетами нужно импортировать во views.py нужный класс из модуля
viewsets и создать класс-наследник.

Модуль viewsets предлагает на выбор несколько классов, и, в зависимости от задачи,
вы можете наследоваться от различных классов.

Универсальный вьюсет ModelViewSet

Класс ModelViewSet может выполнять любые операции CRUD.

В классе-наследнике ModelViewSet обязательно должны быть описаны поля queryset и
serializer_class.

    в поле queryset задаётся выборка объектов модели, с которой будет работать
		вьюсет;
    в поле serializer_class указывается, какой класс будет применён для
		сериализации результатов.

В проекте «API для Yatube» применение вьюсета ModelViewSet может выглядеть так:

	# views.py

	from rest_framework import viewsets
	from .models import User
	from .serializers import UserSerializer


	class UserViewSet(viewsets.ModelViewSet):
		queryset = User.objects.all()
		serializer_class = UserSerializer

Класс ModelViewSet является потомком Viewsets и предоставляет отличный набор
инструментов для всех востребованных операций при работе с моделями, и в
большинстве стандартных ситуаций будет работать «из коробки»: создайте queryset,
подготовьте сериалайзер — и всё готово.

Узнать подробнее о работе ModelViewSet можно в официальной документации.
(https://www.django-rest-framework.org/api-guide/viewsets/)

Роутеры

При работе с вьюсетами можно создавать эндпоинты обычным путём: в urls.py
создать несколько path(), которые свяжут URL и вьюсет.

Но есть более удобный и экономичный инструмент: роутеры (routers). Роутер сам
создаст набор эндпоинтов, нужно лишь указать URL и вьюсет, для которого нужно
их создать.

Для создания роутера в файл urls.py импортируется класс DefaultRouter и создаётся
объект этого класса.

Затем создаётся и регистрируется эндпоинт: для этого у объекта роутера есть метод
register(). В качестве аргументов этот метод принимает URL и класс вьюсета.

После этого надо включить роутер в список urlpatterns.

В коде создание эндпоинтов через router выглядит так:

	# urls.py

	from django.urls import path, include
	from rest_framework.routers import DefaultRouter
	from .views import UserViewSet

	# Создаётся роутер
	router = DefaultRouter()
	# Связываем URL с viewset, аналогично обычному path()
	router.register('api/v1/users', UserViewSet)
	# В роутере можно зарегистрировать любое количество пар "URL, viewset":
	# router.register('api/v1/comments', CommentViewSet)
	# router.register('api/v1/posts', PostViewSet)
	# Но нам это пока не нужно

	urlpatterns = [
		...
		# В список добавляем новый path() с роутером. 
		# Все зарегистрированные в router пути доступны в router.urls
		path('', include(router.urls)),
	]

Только что созданный роутер сгенерирует два эндпоинта:

    api/v1/users/
    api/v1/users/<id>/

Теперь через эти эндпоинты доступны любые операции с моделью:

    POST-запрос на api/v1/users/ создаст новую запись.
    Запросы PUT, PATCH или DELETE к адресу api/v1/users/<id>/ удалят или изменят
		существующую запись.
    GET-запрос на те же адреса вернёт список объектов или один объект.

И на все эти чудеса нам понадобился лишь один роутер и лишь один вьюсет! Выгода
очевидна.

Класс ReadOnlyModelViewSet: только чтение

Существует похожий на ModelViewSet, но ограниченный в правах класс:
ReadOnlyModelViewSet. Он может только получать данные модели, а записывать
и изменять — не может.

Этот класс будет полезен в тех ситуациях, когда требуется только выдавать данные
по запросу. Применяется он точно так же, как и ModelViewSet.

Больше контроля: наследование от ViewSet

В более сложных случаях, когда нужно получить больше контроля и возможностей что-то
«подкрутить», можно наследоваться от базового класса вьюсетов — ViewSet. От этого
базового класса наследуется, например, уже знакомый вам класс ModelViewSet.

Класс ViewSet, в свою очередь, наследуется от APIView. Соответственно, при работе
с ViewSet можно применять такие атрибуты, как permission_classes или
authentication_classes.

В классе ViewSet есть шесть предустановленных методов:

    list() — для чтения списка объектов из queryset
    create() — для создания объекта в модели
    retrieve() — для получения объекта из queryset
    update() — для перезаписи (полного обновления) объекта из queryset
    partial_update() — для частичного обновления объекта из queryset
    destroy() — для удаления объекта из queryset

Чтобы применить любой из этих методов, понадобится полностью описать его: в классе
ViewSet эти методы объявлены, но не описаны.

Например, в приложении нужно создать вьюсет, который будет возвращать
сериализованный объект одного пользователя (методом retrieve()) и полный список
всех пользователей (методом list()):

	from django.shortcuts import get_object_or_404
	from rest_framework import viewsets
	from rest_framework.response import Response
	from .models import User
	from .serializers import UserSerializer


	class UserViewSet(viewsets.ViewSet):
		def list(self, request):
			queryset = User.objects.all()
			serializer = UserSerializer(queryset, many=True)
			return Response(serializer.data)

		def retrieve(self, request, pk=None):
			queryset = User.objects.all()
			user = get_object_or_404(queryset, pk=pk)
			serializer = UserSerializer(user)
			return Response(serializer.data)

Документацию по предустановленным методам класса ViewSet можно посмотреть на
официальном сайте проекта.
(https://www.django-rest-framework.org/api-guide/viewsets/#viewset-actions)

Резюме

Таким образом, вьюсеты и роутеры — это самые высокоуровневые классы для создания
ваших API, в них уже реализованы все стандартные операции и вы можете применять их,
как есть или изменить их под свои требования, если поведение этих классов должно
отличаться от стандартного.

Открытый доступ к вашему API: разрешить CORS

При деплое вашего проекта на веб-сервер вы можете столкнуться с ограничениями на
отправку запросов с других доменов.

По умолчанию отправка запросов ограничивается пределами одного домена:
программа-клиент, отправляющая запрос к серверу, должна находиться в том же домене,
что и веб-сервер, к которому направлен запрос. Это называется «политика единого
источника».(https://www.w3.org/Security/wiki/Same_Origin_Policy)

При взаимодействии программы-клиента с API, находящимся в другом домене
(например, клиент размещён на mysite.ru, а API — на yoursite.ru) — потенциально
возможны проблемы безопасности.

Вы уже сталкивались с этой проблемой при отправке форм. Для защиты от поддельных
запросов вы создавали и отправляли вместе с формой CSRF-токен, по которому сервер
определял, что запрос не подделан.

По умолчанию кросс-доменные запросы запрещены в дефолтных настройках веб-сервера:
это самое простое решение. Но тут возникает другая проблема: к открытому API надо
разрешить запросы с любого домена, иначе какой же он «открытый».

Чтобы к нашему API могли обращаться любые приложения — нужно разрешить фреймворку
использовать CORS.

Cross-Origin Resource Sharing (англ. «совместное использование ресурсов между
разными источниками») — это разрешение на обработку запросов с другого домена.
(https://www.w3.org/TR/cors/)

Для настройки CORS установите пакет django-cors-headers в виртуальном окружении:

	pip install django-cors-headers

Подключите его в settings.py как приложение:

	INSTALLED_APPS = [
		...
		'rest_framework',
		'corsheaders',
	]

И в списке MIDDLEWARE зарегистрируйте обработчик (обязательно перед CommonMiddleware)

	MIDDLEWARE = [
		...
		'corsheaders.middleware.CorsMiddleware',
		'django.middleware.common.CommonMiddleware',
		...
	]

Осталось добавить в конфиг две настройки: CORS_ORIGIN_ALLOW_ALL и CORS_URLS_REGEX:

    CORS_ORIGIN_ALLOW_ALL: значение True, установленное для этого ключа, разрешит
		обрабатывать запросы, приходящие с любого хоста, игнорируя политику
		Some Origin. Если установить False или просто удалить этот ключ из
		конфига — будут разрешены только запросы с текущего хоста.
    CORS_URLS_REGEX: значением этого ключа должно быть регулярное выражение,
		которое определяет URL'ы, к которым можно обращаться с других доменов.

Можно разрешить кросс-доменные запросы к любым адресам домена, но это повысит
уязвимость проекта. Потому включим CORS только для путей с префиксом /api.
В ключе CORS_URLS_REGEX задаём регулярное выражение, описывающее такие пути:

	CORS_ORIGIN_ALLOW_ALL = True
	CORS_URLS_REGEX = r'^/api/.*$'

Для ключа CORS_URLS_REGEX можно указать и несколько значений через запятую,
каждое должно быть в кавычках.

Префикс r перед строкой определяет r-строку. Такую строку система будет читать
как простую последовательность символов, игнорируя escape-последовательности
(escape sequence) — комбинации обратного слеша и символа. Например,
escape-последовательность \n интерпретируется как перенос строки, но в r-строке
это будут просто два текстовых символа безо всякого скрытого смысла.

Настройка доступа к API завершена. Теперь любой клиент с любого домена может
отправлять запросы к вашему API.

Важно: если вы делаете закрытый API, то в CORS_ORIGIN_WHITELIST укажите домен,
с которого разрешены запросы (например, localhost:3000) и удалите ключ
CORS_ORIGIN_ALLOW_ALL (тогда он примет значение по умолчанию: False).

Полное руководство по работе с django-cors-headers находится здесь:
https://github.com/adamchainz/django-cors-headers.

Задание
Предварительная настройка
У вас в репозитории появился проект api_yatube, клонируйте его в свою
рабочую директорию, например, в Dev.

В репозитории — знакомый вам Yatube, но не весь, а только его бэкенд:
приложения, модели. Мы исключили из проекта фронтенд: он не понадобится в работе.

Активируйте виртуальное окружение и установите все необходимые пакеты.
При оформлении проекта принято перечислять все зависимости в файле
requirements.txt, чтобы их потом можно было установить одной командой из
этого файла (обратите внимание на ключ -r, он означает "requirements file",
«файл с требованиями», после этого ключа указывается адрес файла, где сохранены
зависимости):

	pip install -r requirements.txt

Задача

В проекте api_yatube есть приложение posts с описанием моделей Yatube.
Вам нужно реализовать API для всех моделей приложения.

Обычно всю логику API выносят в отдельное приложение: при иной организации
кода работать в большом проекте со множеством приложений будет неудобно.
Но наш проект состоит только из API, поэтому создавать отдельное
приложение не нужно.

Опишите эндпоинты для взаимодействия с ресурсами:

api/v1/posts/ (GET, POST): получаем список всех постов или создаём новый пост
api/v1/posts/{post_id}/ (GET, PUT(PATCH), DELETE): получаем, редактируем
или удаляем пост по id
api/v1/api-token-auth/ (POST): передаём логин и пароль, получаем токен
Если пользователь не авторизован, то API доступен только для чтения.

Пример запроса POST:

    {
        "text": "Вечером собрались в редакции «Русской мысли», чтобы поговорить
			о народном театре. Проект Шехтеля всем нравится."
    }

Пример ответа:

    {
        "id": 14,
        "text": "Вечером собрались в редакции «Русской мысли», чтобы поговорить
			о народном театре. Проект Шехтеля всем нравится.",
        "author": "anton",
        "image": null,
        "pub_date": "2020-04-01T08:47:11.084589Z"
    }

api/v1/posts/{post_id}/comments/{comment_id}/ (GET, PUT(PATCH), DELETE):
получаем, редактируем или удаляем комментарий по id
api/v1/posts/{post_id}/comments/ (GET, POST): получаем список всех комментариев
или создаём новый, передав id поста, который хотим прокомментировать
Пример запроса POST с токеном Антона Чехова: отправляем комментарий к посту с id=14:

    {
        "text": "тест тест",
    }
	
Пример ответа:
	
    {
        "id": 4,
        "author": "anton",
        "post": 14,
        "text": "тест тест",
        "created": "2020-04-01T10:14:51.388932Z"
    }	
	
В ответ на запросы POST и PUT(PATCH) ваш API должен возвращать объект, который
был добавлен или изменён.

Начните с описания файла urls.py на уровне проекта. Он должен включать (include)
маршруты из приложения posts.

Обязательное условие: работайте с моделью Post через ModelViewSet.

Если вы решите, что вьюсеты подойдут и для работы с остальными моделями
— не стесняйтесь, применяйте их везде, где можно.

Ограничения

Не применяйте сторонние библиотеки вроде Nested Routers или её аналогов.
Возможно, это упростит выполнение задания, но мы считаем важным, чтобы вы
реализовали всё самостоятельно.

Отправка запросов и тестирование

Для отправки запросов лучше всего использовать инструмент Postman, который
мы упоминали в прошлых уроках. Скачать его можно на официальном сайте проекта.
(https://www.postman.com/downloads/)

Также вы можете использовать встроенный браузерный клиент Django REST Framework
или консольный клиент HTTPie.(https://httpie.org/)
	
Проект в папке api_yatube
	
