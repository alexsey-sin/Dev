Сериализаторы

Сериализацией называют процесс преобразования данных из одного формата в другой.
Например, можно сериализовать экземпляр класса в объект JSON и обратно.
Вместо JSON может выступать любой другой формат данных, но именно JSON является
стандартом в индустрии и применяется в Django REST Framework по умолчанию.

Работа с запросами к API устроена так: программа-клиент отправляет запрос со
списком параметров на определенный URL. API разбирает эти параметры и отдаёт
клиенту запрошенную информацию. Разбор запроса и создание ответа происходит
во view-функции или view-классе, написанных на Python. И для того, чтобы
разобрать запрос и создать ответ — применяют классы-сериализаторы, переводчики
с JSON на Python и обратно.

По принципу работы сериализаторы очень похожи на формы (Forms), с которыми вы
уже имели дело: они переводят queryset'ы (списки объектов) или отдельные объекты
модели в формат JSON и могут валидировать данные.

Сериализатор не только преобразует данные в JSON, но и указывает, какие поля
включить в выдачу или исключить из неё.

Как и формы, сериализаторы могут быть связаны с моделями, но это не обязательно.
Не связанные с моделями сериализаторы могут обрабатывать произвольные данные,
например, объекты классов Python.

В коде это будет понять проще, чем в теоретическом описании.

Возьмём для примера класс Post, который описывает сущность публикации.
У этого класса есть три поля — автор (для упрощения пусть это будет строка),
текст и дата публикации. Чтобы в ответ на запрос к API вернуть структурированную
информацию о записи, нужно сериализовать объект этого класса в формат JSON.

Код сериализаторов обычно сохраняют в файле serializers.py.
Создадим класс Post и опишем класс-сериализатор PostSerializer.
А затем создадим экземпляр класса Post и передадим его в конструктор сериализатора.
Теперь сериализованные данные хранятся в виде словаря в serializer.data

	from datetime import datetime
	from rest_framework import serializers


	class Post():
		def __init__(self, author, text, pub_date=None):
			self.author = author
			self.text = text
			self.pub_date = pub_date or datetime.now()

	#  создаём сериализатор, наследник предустановленного класса Serializer
	class PostSerializer(serializers.Serializer):
		author = serializers.CharField(max_length=200)
		text = serializers.CharField(max_length=5000)
		pub_date = serializers.DateTimeField()
			
	#  создаём объект класса Post
	post = Post(author='Лев Толстой', text='17 Марта. Написалъ около листа Юности хорошо, но могъ бы написать больше и лучше.')

	#  передаём объект класса Post в сериализатор, чтобы превратить данные объекта в JSON
	serializer = PostSerializer(post)

	#  смотрим, что получилось
	print(serializer.data)
	#  будет напечатано: {'author': 'Лев Толстой', 'text': '17 Марта. Написалъ около листа Юности хорошо, но могъ бы написать больше и лучше.', 'pub_date': '2020-03-23T18:02:33.123543Z'}

При работе с базой данных удобнее всего создавать сериалайзер на основе
класса ModelSerializer. Этот класс автоматически генерирует ответ на основе
модели и валидирует поля, включённые в ответ.

Для создания сериалайзера на основе ModelSerializer нужно:

    унаследоваться от ModelSerializer;
    указать модель, с которой надо работать;
    указать поля, которые нужно включить в ответ:

	from rest_framework import serializers
	from .models import User

	class UserSerializer(serializers.ModelSerializer):
		class Meta:
			fields = '__all__' # либо явно перечисляем необходимые поля в виде кортежа
			model = User

Подробнее почитать про ModelSerializer можно здесь:
https://github.com/ilyachch/django-rest-framework-rusdoc/blob/master/api-navigation/serializers.md#modelserializer

===============================================================================
Тренажер - проект

Задача:
Допишите код.
При запросе адреса api/v1/posts/ должна вызываться view-функция get_post, а
в качестве параметра ожидается переменная post_id с целочисленным значением.

Что такое v1? Это версия вашего API. Предусмотрим возможность дальнейшего
развития проекта и сразу начнём версионировать API, чтобы сохранить обратную
совместимость.

Опишите view-функцию get_post , которая в ответ на GET-запрос будет возвращать
объект публикации по его id. Для формирования ответа используйте класс JsonResponse
из модуля django.http: передайте в конструктор класса JsonResponse данные из
сериализатора.

Подсказка:
    В файле urls.py пропишите маршрут api/v1/posts/, который передает целочисленный
		аргумент post_id и вызывает view-функцию get_post
    В файле views.py опишите view-функцию, которая принимает в качестве аргумента
		параметр post_id
    В теле view-функции должен создаваться объект публикации, соответствующий
		переданному post_id
    Объект должен быть передан сериализатору PostSerializer
    Функция формирует ответ, передавая serializer.data в класс JsonResponse

Проект в папке progect_4
===============================================================================
