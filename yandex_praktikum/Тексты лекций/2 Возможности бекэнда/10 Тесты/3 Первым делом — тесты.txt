Первым делом — тесты: Test-driven Development

Написание тестов — это большая часть работы программиста. Высший пилотаж
в этой разработке — сначала придумать модуль и написать для него тесты,
а потом написать код, соответствующий этим тестам.

Такой подход можно встретить и в спортивном программировании. Организаторы
дают участникам задания-тесты, а решение должно соответствовать этим тестам.

Учебный курс Яндекс.Практикум, который вы проходите, устроен по тому же
принципу: мы пишем тесты для заданий, а вы пишете решения, которые соответствуют
этим тестам.

Практика «сначала тесты, потом — код» называется Test Driven Development (TDD).

После тестов пишется код, и тестирование этого кода выполняется по простому
принципу: если код выполняет задачу — это хороший код; если не выполняет
— "Thank you Mario! But your princess is in another castle", напишите код иначе.

В часах, например, нам важно, показывают ли они точное время, но как именно
соединены в них шестерёнки и есть ли они там вообще — интересно только часовщику.

Строка наизнанку

Придумаем лингвистический проект LingvoBoost, в котором должен быть модуль
invertor. Этот модуль принимает на вход строку, инвертирует её и возвращает.
Неизвестно, по какому алгоритму он будет работать, но это не мешает написать тест.

Требования к функции-инвертору нам известны: на вход она принимает строку,
а возвращает перевёрнутую строку. Например, строка «Попугай» должна превратиться
в «йагупоП».

	def invertor(text):
		"""Инвертирует строку 
		>>> invertor('Попугай')
		йагупоП
		"""
		...

Для тестирования потребуется несколько ассертов — нужно проверить, корректно ли работает функция-инвертор

    с обычной строкой:
    assert invertor('Попугай') == 'йагупоП', 'Инвертор не работает со строкой "Попугай"'
    и с пустой строкой:
    assert invertor('') == '', 'Инвертор не работает с пустой строкой'

Эти ассерты удобно собрать в одну функцию и затем вызывать её для тестирования.
Названия тестирующих функций принято начинать с префикса test_

Тестирующая функция будет принимать на вход функцию-инвертор, а тестовый
аргумент и ожидаемый результат работы функции будут заданы прямо в теле теста.

Чтобы по результатам тестирования можно было понять, в каком из тестов возникла
проблема — полезно вывести на экран дополнительную информацию: название теста
(его укажем в docstring) и название тестируемой функции.

К docstring функции test_invert() можно обратиться через test_invert.__doc__,
а имя тестируемой функции хранится в переменной invertaser.__name__. 

	# Тестирующая функция принимает на вход тестируемую функцию
	def test_invert(invertaser):    
		"""Тест алгоритма инвертирования строки."""

		# Напечатать информацию о тесте из docstring
		print(f'{test_invert.__doc__}')
	   
		# Напечатать имя тестируемой функции
		print(f'Тестирование алгоритма {invertaser.__name__}')

		source = 'Попугай'
		inversed = 'йагупоП'

		# Проверяем утверждение, что вызов invertaser('Попугай') вернёт строку 'йагупоП'
		# В сообщении об ошибке указываем название тестируемой функции и инвертируемую строку
		assert invertaser(source) == inversed, (
			f'Алгоритм в {invertaser.__name__} работает неправильно со строкой "{source}" ')
		
		# Следующий тест: передадим в тестируемую функцию пустую строку
		source = ''
		# Ожидаемый результат работы тестируемой функции: пустая строка 
		inversed = ''
		
		# Проверяем утверждение: вызов функции с пустой строкой вернёт пустую строку
		assert invertaser(source) == inversed, (
			f'Алгоритм {invertaser.__name__} работает неправильно с пустой строкой')

		# Если ислючение в assert не сработало - 
		# на экран будет выведено сообщение об успешном прохождении теста
		print(f'Тест для {invertaser.__name__} пройден успешно')

Теперь в функцию test_invert() можно передать на вход тестируемую функцию.
Тестируемая функция будет вызвана с аргументом "Попугай", результат работы
тестируемой функции будет передан в assert и проверен на совпадение с ожидаемым
результатом.

Протестировать функцию-инвертор можно и обычным ассертом, не упаковывая его
в функцию. Но если потребуется тестировать много разных функций-инверторов
— для каждой из них придётся писать отдельный assert. А если тесты собраны
в функцию, достаточно вызвать эту функцию несколько раз, передавая в неё
тестируемые функции.

Предположим, что несколько разработчиков написали несколько функций-инверторов
— и надо проверить их работу: тесты должны определить, выполняют ли эти функции
поставленную задачу.

Для этого нужно несколько раз вызвать тестирующую функцию, передавая в неё
тестируемые функции-инверторы.

Запустите этот код в VSC или в другом редакторе — и посмотрите на результат.

	def test_invert(invertaser):
		"""Тест алгоритма инвертирования строки."""

		print(f'{test_invert.__doc__}')
		print(f'Тестирование алгоритма {invertaser.__name__}')

		source = 'Попугай'
		inversed = 'йагупоП'

		assert invertaser(source) == inversed, (
			f'Алгоритм в {invertaser.__name__} работает неправильно со строкой "{source}" ')
		
		source = ''
		inversed = ''

		assert invertaser(source) == inversed, (
			f'Алгоритм {invertaser.__name__} работает неправильно с пустой строкой')

		print(f'Тест для {invertaser.__name__} пройден успешно')


	# Ниже - несколько функций, инвертирующих строку. 
	# Их и будем тестировать.
	def recursion_invertor(text):
		"""Инвертирует строчку рекурсивно"""
		if len(text) == 0:
			return text
		else:
			return recursion_invertor(text[1:]) + text[0]


	def slice_invertor(text):
		"""Инвертирует строчку срезом"""
		return text[::-1]


	def iterator_invertor(text):
		"""Инвертирует строчку обратной итерацией"""
		return ''.join(reversed(text))


	def reverselist_invertor(text):
		"""Инвертирует строчку переворотом списка"""
		inversed_list = list(text)
		inversed_list.reverse()
		return ''.join(inversed_list)

	# Вызов тестирующей функции для каждой функции-инвертора
	test_invert(recursion_invertor)
	test_invert(slice_invertor)
	test_invert(iterator_invertor)
	test_invert(reverselist_invertor)

Можете написать свою функцию и протестировать её. А можете поломать
какую-нибудь из готовых функций и посмотреть, что получится.

Для уверенности в результатах можно протестировать заведомо неработающую
функцию. Если такая функция не провалит тест — значит, с тестом что-то не ладно.

	def unworked_sort(array):
		"""Функция не делает ничего."""
		...

На практике тесты хранят отдельно от рабочего кода: это позволяет не смешивать
основной код и тестирующие функции.

===============================================================================
Тренажер

Задача:

Допишите тестирующую функцию test_sort(). Она должна проверять функции,
сортирующие списки из чисел по возрастанию (от меньшего к большему).

Например, если на вход такая функция получит список [1, 3, 2, 4],
то вернуть она должна [1, 2, 3, 4]

В прекоде заготовлен вызов тестирования нескольких сортирующих функций
(эти функции хранятся в пакете ttd_sprint5_data, их код вам не виден).

В тесте проверьте, работают ли эти функции

    со списком, содержащим int и float;
    со списком, содержащим отрицательные величины, нулевое значение;
    со списком, содержащим одинаковые числа;
    с пустым списком (всегда стоит проверять граничные значения).

Часть функций не пройдёт все тесты.

Когда вы обнаружите неработающие функции — удалите из кода строки,
где они вызываются для тестирования. После этого отправляйте код на проверку.

Подсказка:

Каждую проверку описывайте в отдельном ассерте, задавая для тестируемой
функции нужный аргумент и ожидаемый ответ.

******************************************
	def test_sort(sorting_algorithm):
		""" Тестируем алгоритм, сортирующий список по возрастанию."""
		# Напечатать имя функции
		print(f'Тестируем функцию: {sorting_algorithm.__name__}')

		source = [1, 3, 2, 4]
		result = [1, 2, 3, 4]
		assert sorting_algorithm(source) == result, 'Error1'
		source = [4, 3.1, 2.5, 1]
		result = [1, 2.5, 3.1, 4]
		assert sorting_algorithm(source) == result, 'Error2'
		source = [1, 4, -2, 0]
		result = [-2, 0, 1, 4]
		assert sorting_algorithm(source) == result, 'Error3'
		source = [2, 2, 1, 4]
		result = [1, 2, 2, 4]
		assert sorting_algorithm(source) == result, 'Error4'
		source = []
		result = []
		assert sorting_algorithm(source) == result, 'Error5'
	 
		print(f'Тест для {sorting_algorithm.__name__} пройден')
		
	# Ипортируем тестируемые функции из пакета ttd_sprint5_data
	test_sort(ttd_sprint5_data.bubble_sort)
	test_sort(ttd_sprint5_data.timsort_sort)
	test_sort(ttd_sprint5_data.selection_sort)
	test_sort(ttd_sprint5_data.insertion_sort)
	# test_sort(ttd_sprint5_data.cap_sort) 
	test_sort(ttd_sprint5_data.merge_sort)
	test_sort(ttd_sprint5_data.heap_sort)
	# test_sort(ttd_sprint5_data.stepa_sort)  
	test_sort(ttd_sprint5_data.quick_sort)
	test_sort(ttd_sprint5_data.sus_sort)
******************************************
===============================================================================
