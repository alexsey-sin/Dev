Вкалывают роботы: assert

Тестирование кода в doctest — хороший, но не универсальный способ.

Быстро протестировать небольшой фрагмент кода и убедиться, что он работает
— для этого doctest вполне подходит. Но зачастую такое тестирование неудобно:
тесты загромождают код, а вынести в отдельный файл их нельзя.

Это серьёзная проблема: ведь тесты зачастую объёмнее, чем тестируемые функции.

Есть другой, более универсальный и гибкий метод тестирования, основанный
на встроенной в Python инструкции assert (англ. «утверждение»).

Assert работает по такой логике: разработчик передаёт в него какое-то утверждение,
и если оно истинно — assert не возвращает ничего, тест пройден.
Если утверждение оказалось ложным — выбрасывается исключение с сообщением об ошибке,
а исполнение кода прерывается. 

	# Синтаксис:
	assert <проверяемое утверждение>, <'Сообщение об ошибке'>

	# В этом примере утверждение (первый аргумент) - True. 
	# Код продолжит выполняться, сообщение не будет выведено
	assert 1 == 1, 'Хьюстон, у нас проблемы'

	# В этом примере утверждение (первый аргумент) - False
	assert 2 + 2 == 5, 'Хьюстон, у нас проблемы'

	# в результате будет вызвано исключение с текстом из второго аргумента,
	# а выполнение кода будет остановлено
	>Traceback (most recent call last):
	>  File "1.py", line 25, in <module>
	>    assert False, 'Хьюстон, у нас проблемы'
	>AssertionError: Хьюстон, у нас проблемы

Если утверждение в assert возвращает False — вызывается исключение,
и выполнение кода прерывается.

Тонкости форматирования

При переносе длинных строк в assert есть важный нюанс:
не заключайте в скобки оба аргумента (проверяемое утверждение
и сообщение об ошибке), иначе assert решит, что вы передали в него
непустой кортеж, а он приводится к True.

Протестируйте этот код в редакторе: утверждение 2 + x == 4 ложно
(ведь x = 3), но assert не вернёт сообщение об ошибке.

	x = 3

	# Такой перенос строк всё испортит, при любом x утверждение вернёт True:
	assert (2 + x == 4, 'Очень длинная строка, в которой многословно, '
						'с лирическими отступлениями, описывается, '
						'какой именно тест провален.')

В таком assert тесты всегда будут возвращать результат «утверждение верно»,
что бы ни творилось в проверяемом коде.

IDE подсвечивает ошибку переноса строки, но, тем не менее, нужно помнить
об этой проблеме.

При переносе длинных строк в assert замыкайте в скобки только переносимую
строку, и фрагмент на каждой строке обрамляйте в кавычки:

	x = 3
	assert 2 + x == 4, ('Очень длинная строка, в которой многословно, '
						'с лирическими отступлениями, описывается, '
						'какой именно тест провален.')

Assert для функции

Ассерты (в отличие от доктестов) не обязательно размещать в тестируемой функции.
Ассерты можно компоновать в классы или в функции, выносить в другие файлы и,
при необходимости, импортировать и вызывать. В результате код становится чище,
с ним проще работать и легче читать.

Протестировать функцию с помощью assert достаточно просто: в первом аргументе
нужно сравнить результат реального вызова функции и ожидаемый результат.

Вы уже тестировали функцию movie_quotes() в ручном режиме и через doctest.
Теперь пусть поработает assert. Запустите этот код в Visual Studio Code.

	def movie_quotes(name):
		"""Возвращает цитаты известных персонажей из фильмов."""
		quotes = {
			'Элли': 'Тото , у меня такое ощущение, что мы не в Канзасе!',
			'Шерлок': 'Элементарно, Ватсон!',
			'Дарт Вейдер': 'Я — твой отец.',
			'Thomas A. Anderson': 'Меня зовут Ханс. Ханс Кристиан Андерсен.',
		}
		return quotes.get(name, 'Персонаж пока не известен миллионам.')

	# Утверждаем, что если в movie_quotes() передать 'Шерлок' -
	# функция вернёт 'Элементарно, Ватсон!'.
	assert movie_quotes('Шерлок') == 'Элементарно, Ватсон!', (
	   "movie_quotes('Шерлок') не вернул ожидаемый результат!")

	# Утверждаем, что если в movie_quotes() передать 'Thomas A. Anderson' -
	# функция вернёт 'Меня зовут Нео!'.
	assert movie_quotes('Thomas A. Anderson') == 'Меня. Зовут. Нео!', (
		"movie_quotes('Thomas A. Anderson') не вернул ожидаемый результат!")

	# Утверждаем, что если в movie_quotes передать 'Алиса Плезенс Лидделл' -
	# функция вернёт 'Всё чудесатее и чудесатее!'.
	expected_answer = 'Всё чудесатее и чудесатее!'
	assert movie_quotes('Алиса Плезенс Лидделл') == expected_answer, (
		"movie_quotes('Алиса Плезенс Лидделл') не вернул ожидаемый результат!")

Тест провален: при вызове movie_quotes('Thomas A. Anderson') Нео зачем-то
представился именем великого сказочника.

Ошибка найдена; исправьте элемент словаря quotes с ключом Thomas A. Anderson:
его значением должно быть 'Меня. Зовут. Нео!'.

Запустите код ещё раз.

Опять ошибка, теперь в другом ассерте: в тесте ожидалась реплика Алисы,
но функция вернула совсем другую строку. Добавьте новый элемент c ключом
Алиса Плезенс Лидделл в словарь quotes. Значение для этого элемента возьмите
из ассерта.

Вот теперь порядок. Тесты пройдены, код отлажен и работает.

Assert для классов

Вот класс, описывающий отдельную запись в контакт-листе (вы уже работали
с этим классом и отлично аннотировали его):

	class Contact:
		def __init__(self, name, year_birth, is_programmer):
			self.name = name        
			self.year_birth = year_birth        
			self.is_programmer = is_programmer

		def age_define(self):
			if 1946 < self.year_birth < 1980:
				return 'Олдскул'
			if self.year_birth >= 1980:
				return 'Молодой'
			return 'Старейшина'

		def programmer_define(self):
			if self.is_programmer:
				return 'Программист'
			return 'Нормальный'

		def show_contact(self):
			return(f'{self.name}, '               
				   f'категория: {self.age_define()}, '
				   f'статус: {self.programmer_define()}')

		def print_contact(self):
			print(self.show_contact())

Чтобы протестировать этот класс, проще всего создать его экземпляр и убедиться,
что поведение экземпляра соответствует ожиданиям.

	mike: Contact = Contact('Михаил Булгаков', 1891, False)

	expected_string = 'Михаил Булгаков, категория: Старейшина, статус: Нормальный'

	assert mike.show_contact() == expected_string, 'Ошибка в Contact.show_contact()'

За кулисами assert

При обработке инструкций assert Python преобразовывает каждую из них примерно
в такую конструкцию:

	if __debug__:
		if not <утверждение>:
			raise AssertionError(<сообщение об ошибке>)

Эта инструкция работает только в том случае, когда для встроенной константы
Python __debug__ установлено значение True. При оптимизации проекта это значение
меняют на False, и в таком режиме ассерты игнорируются.

Применяйте assert только для тестирования. Практичность таких тестов в том,
что их можно поставить в любом месте кода и быстро проверить какой-то фрагмент
программы.

Doctest или assert — что правильно?

Правильны и полезны оба подхода, их можно применять как по отдельности,
так и совместно. Выбор варианта зависит от сложности и структуры тестируемого
объекта: как правило, doctest применяют для быстрого простого тестирования
небольших фрагментов кода.

===============================================================================
Тренажер

Задача 1/2:

Протестируйте функцию series_sum().
Напишите тесты, которые проверят, что будет, если:

    передать в функцию список чисел int и float вперемежку;
    передать в функцию список, состоящий из чисел и строк;
    передать в функцию пустой список.

Подсказка:

В первом аргументе инструкции assert запишите равенство, которое должно
быть проверено на истинность. В левой части этого равенства должен быть
вызов функции series_sum(), в которую передан список с необходимым содержанием.
В правой части этого равенства — строка, составленная из конкатенированных
элементов этого списка:

assert series_sum(список1) == 'строка из конкатенированных элементов', 'Сообщение об ошибке'

	def series_sum(incoming):
		# Конкатенирует все элементы списка, приводя их к строкам."
		result = ''
		for i in incoming:
			result += str(i)
		return result

	# Первое тестирование: проверьте, корректно ли сработает функция series_sum(),
	# если ей на вход передать список из целых и дробных чисел.

	mixed_numbers =  [1, 8, 7, 5.23, 3, 6.54, 10]
	result_numbers =  '1875.2336.5410'

	# Вместо многоточия напишите утверждение, которое должно быть проверено
	assert series_sum(mixed_numbers) == result_numbers, (
		'Функция series_sum() не работает со списком чисел')

	# Второе тестирование: проверьте, корректно ли сработает функция series_sum(),
	# если ей на вход передать список из чисел и строк.

	mixed_numbers_strings =  [1, 8, 'dss', 5.23, 3, 'abba', 10]
	result_numbers_strings =  '18dss5.233abba10'

	# Вместо многоточия напишите утверждение, которое должно быть проверено
	assert series_sum(mixed_numbers_strings) == result_numbers_strings, (
		'Функция series_sum() не работает со смешанным списком')

	# Третье тестирование: проверьте, корректно ли сработает функция series_sum(),
	# если ей на вход передать пустой список.
	empty =  []
	result_empty = ''

Задача 2/2:

Протестируйте методы programmer_define() и age_define() класса Contact.
Тестировать нужно все состояния: в метод programmer_define() надо
по очереди передать False и True, а в age_define() надо проверить
все возрастные категории.

Для проверки всех возможных вариантов создайте несколько экземпляров
класса Contact с разными значениями полей year_birth и is_programmer.

Подсказка:

Создайте несколько экземпляров класса Contact, в каждом экземпляре задайте
разные значения для year_birth и is_programmer.

Для каждого экземпляра напишите отдельный assert, вызывая проверяемый
метод и сравнивая возвращаемое значение с ожидаемым.

	class Contact:
		def __init__(self, name, year_birth, is_programmer):
			self.name = name        
			self.year_birth = year_birth        
			self.is_programmer = is_programmer

		def age_define(self):
			if 1946 < self.year_birth < 1980:
				return 'Олдскул'
			if self.year_birth >= 1980:
				return 'Молодой'
			return 'Старейшина'

		def programmer_define(self):
			if self.is_programmer:
				return 'Программист'
			return 'Нормальный'

		def show_contact(self):
			return(f'{self.name}, '              
				   f'возраст: {self.age_define()}, '
				   f'статус: {self.programmer_define()}')

		def print_contact(self):
			print(self.show_contact())

	# Создайте экземпляр класса Contact с необходимыми параметрами
	# Например, test_old_none_programmer = Contact('Пушкин', 1799, False).
	# Напишите assert, и в нём проверьте, 
	# что метод programmer_define() этого экземпляра возвращает строку "Нормальный"
	# Во втором assert проверьте, возвращает ли метод age_define() значение "Старейшина"
	test_old_none_programmer = Contact('Пушкин', 1799, False)
	assert test_old_none_programmer.programmer_define() == 'Нормальный', 'Error_programmer_define1'

	# Затем создайте другой экземпляр с другими параметрами
	# И в assert проверьте, вернут ли и его методы ожидаемый результат.
	test_yang_programmer = Contact('Пронин', 1975, True)
	assert test_yang_programmer.programmer_define() == 'Программист', 'Error_programmer_define'

	# Создайте столько экземпляров, сколько нужно, 
	# чтобы через разные assert проверить все методы во всех вариантах.
	test_people1 = Contact('Васин', 1988, False)

	assert test_old_none_programmer.age_define() == 'Старейшина', 'Error_age_define1'
	assert test_yang_programmer.age_define() == 'Олдскул', 'Error_age_define2'
	assert test_people1.age_define() == 'Молодой', 'Error_age_define3'

	assert test_yang_programmer.show_contact() == 'Пронин, возраст: Олдскул, статус: Программист', 'show_contact'

===============================================================================
