Мануальное тестирование

Лавина изменений в коде

Выполнение каждой новой задачи затрагивает код многих файлов проекта.
С ростом сложности кода любое изменение начинает порождать волны правок
в функциях и шаблонах, требует создания файлов миграции и многих других изменений.
От разработчика будет требоваться всё больше и больше памяти и внимания,
но этим качествам есть предел.

В прошлом спринте вы сделали форму по обмену дисками: в ней были поля
«Исполнитель» и «Название альбома». И вот перед сдачей проекта коллекционер
просит вас добавить в описание альбома поле «Год выпуска».

В проекте придётся исправить:

    объект формы;
    view-функцию index, которая вызывает функцию send_msg;
    определение самой функции send_msg(): в неё надо будет передать
		дополнительный параметр date;
    шаблон текста письма: в него надо добавить новое поле;
    возможно, изменений потребует и шаблон формы в файле index.html;
    а если бы данные из формы сохранялись в базу, то пришлось бы править
		модель и делать миграцию.

И всё это надо будет исправить в крошечном проекте с одной-единственной формой!

Что делать? Тестировать!

Некоторый опыт в тестировании у вас уже накоплен:

    открыть проект, чтобы проверить, работает ли он;
    проверить работу формы или шаблона;
    пройтись по ссылкам проекта, чтобы убедиться, что они работают;
    запустить функцию и посмотреть, возвращает ли она то, что ожидалось

— что это, если не тестирование?

Протестируйте фрагмент кода из листинга — вызовите эту функцию с разными
аргументами и проверьте, корректно ли она работает:

	def movie_quotes(name):
		"""Возвращает цитаты известных персонажей из фильмов."""
		quotes = {
			'Элли': 'Тото, у меня такое ощущение, что мы не в Канзасе!',
			'Шерлок': 'Элементарно, Ватсон!',
			'Дарт Вейдер': 'Я — твой отец.',
			'Thomas A. Anderson': 'Меня. Зовут. Нео!',
		}
		# Метод словаря get() возвращает значение для указанного ключа.
		# Если запрошенный ключ не найден — get() вернёт значение,
		# указанное вторым аргументом.
		return quotes.get(name, 'Персонаж пока не известен миллионам.')

Варианты вызова и ожидаемые результаты:

	print(movie_quotes('Элли'))
	# Ожидаемый результат: 'Тото, у меня такое ощущение, что мы не в Канзасе!'

	print(movie_quotes('Шерлок'))
	# Ожидаемый результат: 'Элементарно, Ватсон!'

	print(movie_quotes('Дарт Вейдер'))
	# Ожидаемый результат: 'Я — твой отец.'

	print(movie_quotes('Леонид Тощев'))
	# Ожидаемый результат: 'Персонаж пока не известен миллионам.'

Отлично, вы провели мануальное (от англ. manual: «ручное») тестирование функции.
В своё время это случается с каждым разработчиком.

Результаты мануального тестирования можно сохранить в Docstring, где они
станут доступны вашим коллегам-разработчикам.

Документируй это: Docstring и Doctest

Docstring — это строковая переменная, которую размещают сразу за объявлением
модуля, функции, класса или метода. Docstring принято обрамлять тройными
двойными кавычками (РЕР257)(https://www.python.org/dev/peps/pep-0257/).
Доступ до этой переменной можно получить так: имя_функции.__doc__.

В docstring вносят краткое смысловое описание класса или функции, к которой
она относится. В ней же, при необходимости, сохраняют результаты проведённых
тестов.

Сохраните код из листинга в файл расширением .py.

	def movie_quotes(name):
		"""Возвращает цитаты известных персонажей из фильмов

		>>> movie_quotes('Элли')
		'Тото, у меня такое ощущение, что мы не в Канзасе!'

		>>> movie_quotes('Шерлок')
		'Элементарно, Ватсон!'

		>>> movie_quotes('Дарт Вейдер')
		'Я — твой отец.'

		>>> movie_quotes('Леонид Тощев')
		'Персонаж пока не известен миллионам.'
		"""
		quotes = {
			'Элли': 'Тото, у меня такое ощущение, что мы не в Канзасе!',
			'Шерлок': 'Элементарно, Ватсон!',
			'Дарт Вейдер': 'Я — твой отец.',
			'Thomas A. Anderson': 'Меня. Зовут. Нео!',
		}
		return quotes.get(name, 'Персонаж пока не известен миллионам.')

В docstring функции добавлено описание результатов проведённого тестирования.

Посмотрите на эти смешные ёлочки >>>: они тут не просто так. В Python есть
стандартная библиотека doctest; при запуске она ищет в Docstrings эти ёлочки
и исполняет инструкции, следующие за ними; затем doctest сравнивает полученный
результат с ожидаемым, указанным на следующей за инструкцией строке в docstring.

Теперь код под контролем: можно без опасений редактировать, расширять или
рефакторить функцию, и если в результате изменений она перестанет возвращать
ожидаемые результаты — разработчик немедленно узнает об этом. И не нужно будет
заново вручную тестировать функцию и сверять полученные результаты с ожидаемыми.

Запустите doctest для файла с функцией movie_quotes(): выполните из директории
с файлом команду python3 -m doctest <название файла.py>

В файле можно настроить и автоматический запуск тестирования: нужно импортировать
doctest в код и добавить вызов теста.

	# Код с докстрингами

	if __name__ == "__main__": 
		import doctest
		doctest.testmod()

Теперь doctest будет запускаться автоматически при выполнении файла.

	python3 <название файла.py>
	# Вначале будет выполнен doctest, а затем - код файла

Если команда выполнена, но ничего не произошло — значит все работает правильно
и результаты теста, сохранённые в докстринге, подтверждены.

Сломайте код (например, добавьте лишний пробел в цитату с Элли) и заново
запустите doctest.

	В консоли появится сообщение об ошибке:

	<адрес и имя файла>line 6, in tmp.movie_quotes
	Failed example:
		movie_quotes('Элли')
	Expected:
		'Тото, у меня такое ощущение, что мы не в Канзасе!'
	Got:
		'Тото , у меня такое ощущение, что мы не в Канзасе!'
	**********************************************************************
	1 items had failures:
	   1 of   4 in tmp.movie_quotes
	***Test Failed*** 1 failures.

Doctest обнаружил расхождение с ожидаемым результатом и указал на него.
Это самый простой способ работы с doctest. Но этот пакет способен на большее;
все его возможности описаны в документации:
https://docs.python.org/3/library/doctest.html.

Документируйте код и сохраняйте результаты тестирования, от этого ваши коллеги
будут спокойнее спать по ночам: код проверен, код работает. Кстати, о коллегах:
умение писать документацию повысит ваши шансы на собеседовании.

В прошлой домашке вы сделали систему публикаций постов. Потестируйте эту систему
с пользовательской стороны.

Технических ошибок не обнаружено, а по результатам последнего теста обнаружилась
приятная особенность Django: он сам умеет определять, что пользователь пытается
отправить через TextField сообщение, состоящее лишь из пробела — и пресекает такие
попытки.

Валидацию не писали, а она есть.

В реальной жизни тестировщик (в этом уроке это вы) оформляет результаты
тестирования и список ошибок в удобный читаемый вид и передаёт разработчику.
Разработчик (это вы) исправляет ошибки и передаёт проект на повторное тестирование.

Сейчас это делать не обязательно.
