Шаблоны Django

Вы получили нужные записи из базы данных и вывели их на главную страницу сайта.
С технической стороны всё хорошо, но страница выглядит ужасно. Пора подключить
HTML-шаблоны — вы познакомились с ними на бесплатном курсе по Django.

Механизм шаблонов даёт возможность передать данные из view-функции в HTML-документ
и вернуть пользователю полноценную веб-страницу.

HTML-шаблоны — это статичные HTML-файлы, они заранее создаются
разработчиками-фронтендерами и сохраняются в отдельной директории.

Шаблон — это как красивая пустая коробка, в которую в нужный момент «упаковывают»
данные; для данных в этой «коробке» заранее подготовлены «ячейки»: в коде шаблона
расставлены переменные, на место которых будут выведены реальные данные.

Рендеринг шаблона

Процесс сборки возвращаемой страницы называется rendering (англ. «отрисовка»).

Рендеринг — это превращение исходного кода в результат, который видит пользователь.
Например, 3D-мультипликаторы в программах трёхмерной графики создают персонажей и
эффекты, а потом, после рендеринга исходных файлов, получается видео.

При рендеринге HTML-страницы в шаблон вставляются сгенерированные данные, а сама
страница может «монтироваться» из нескольких шаблонов.

За рендеринг страницы отвечает встроенная в Django функция render(): на вход она
принимает имя HTML-шаблона и словарь с данными, которые нужно вставить в шаблон,
а возвращает объект класса HttpResponse, объект HTTP-ответа. В объекте HttpResponse
передаётся готовый HTML-код возвращаемой страницы.

Данные в шаблон передают в словаре (dict), обычно этот словарь называют context.
Значениями элементов этого словаря могут быть любые данные.

	from django.shortcuts import render

	def my_index(request):
		# какой-то код
		title = 'Заголовок страницы'
		body = 'Текст страницы'
		# Сгенерированные во view-функции данные сохраняем в словарь
		context = {'title': title, 'body': body}

		# вызов функции render():
		# первый параметр — это всегда request, объект запроса
		# второй параметр - имя шаблона, в который будут "обёрнуты" данные
		# третий параметр - словарь с переменными, которые передаются  в шаблон
		return render(request, 'index.html', context)

Вывод переменных в HTML-шаблон
В шаблоне index.html предусмотрены места, куда будут выведены значения элементов
title и body из словаря context. Имя переменной в шаблоне указывают в двойных
фигурных скобках {{ и }}:

<h1>{{ title }}</h1>
<p>{{ body }}</p> 

В словаре context можно передать в шаблон любые данные: строки, списки, словари,
объекты классов — всё, что необходимо.

Обратиться в шаблоне к элементу словаря, свойству объекта или элементу списка можно
через точечную нотацию:

	{{ var_dict.key }} — обращение к ключу словаря
	{{ var_instance.attribute }} — обращение к свойству или методу класса
	{{ var_list.0 }} — обращение к элементу списка 

Процессор шаблонов упрощает и унифицирует обращение к свойствам и ключам объектов.

Например если объект user содержит свойство username, то обратиться к этому
свойству в шаблоне можно точно так же, как в Python: {{ user.username }}.

Если user — это словарь, в котором есть ключ username, то обращение к этому ключу
в шаблоне будет точно таким же, как и в первом случае: {{ user.username }}.

Если у объекта есть метод, то обращаются к нему так же, как к свойству.
Обработчик шаблона сам определит, что надо вызвать метод — и опубликует результат
вызова.

Теги

Для более сложных конструкций, влияющих на логику исполнения кода, существуют
элементы разметки, теги. Это иное, чем HTML-теги, в коде они выделяются
конструкциями {% и %}.

Теги шаблонизатора могут быть одиночные:

	{% include "footer.html" %} 

или парные, состоящие из открывающего и закрывающего тегов:

	{% block %}
	  тело тега
	{% endblock %} 

Что умеют теги

Тег ветвления {% if %} очень похож на оператор if/elif/else в языке Python.
Обратите внимание: у тега if обязательно должен быть закрывающий тег endif:

	{% if user.is_authenticated %}
	  Привет, {{ user.username }}.
	{% else %}
	  Будет здорово, если вы авторизуетесь!
	{% endif %} 

В зависимости от того, авторизован пользователь или нет, будет выведен нужный
вариант текста.
У тегов могут быть параметры. Например, "counter.html" — это параметр тега include:

	{% include "counter.html" %} 

На место этого тега в шаблон будет встроено содержимое другого шаблона,
файла counter.html.

В Django есть много встроенных тегов, но их можно создать и самостоятельно.
(https://docs.djangoproject.com/en/2.2/ref/templates/builtins/#ref-templates-builtins-tags)

Фильтры в HTML-шаблонах

Фильтры обрабатывают значения переменных или аргументов других тегов.

Фильтр length

Например, фильтр length вернёт длину строки или последовательности, переданной
в переменной variable. В коде фильтры присоединяются к имени переменной через
символ |:

{{ variable|length }} 

Если в переменную variable передать слово «гиппопотомомонстросесквиппедалиофобия»,
то в шаблон будет выведено число 37, по числу букв в слове.

Фильтр safe

Если в шаблон передать строку с HTML-тегами и вывести её на страницу, то
HTML-теги будут выведены на страницу как обычный текст.

	# views.py
	...
	def poem(request):
		text = ('Вчера Крокодил<br>улыбнулся так злобно,<br>Что мне до сих '
				'пор<br>за него неудобно.<br><i>Рената Муха</i>'
				)
		context = {'poem': text}
		render(request, 'poem.html', context)

	{# poem.html #}
	<h2>Стихотворение</h2>
	{{ poem }} 

Чтобы HTML-теги не вываливались на страницу, а выполняли своё предназначение
(форматировали и структурировали страницу) — в шаблоне необходимо применять
фильтр safe:

	<h2>Стихотворение</h2>
	{{ poem|safe }} 

Фильтр linebreaksbr

При выводе текстов есть и другие особенности. При написании текста начало новой
строки обычно обозначают нажатием Enter/Return, но HTML игнорирует такой перенос
строк. Если передать на страницу текст с таким разбиением на строки — он будет
выведен сплошным потоком, одной строкой, ведь перенос строки в HTML обозначается
тегом <br>.

В Django Templates есть фильтр linebreaksbr. Он заменяет символы перевода строки
\n на HTML-теги <br>.

Фильтр date

Фильтр date работает только с объектами типа date и datetime: он форматирует дату
по маске. За основу взят стандарт, принятый в языке программирования PHP.

Если вывести дату без форматирования, то получится что-то вроде
'2019-02-02 00:00:00+00:00'. Это не лучший вариант.
Фильтр date позволяет вывести дату в любой форме: 

	{{ pub_date|date:"j.m.Y" }} {# выведет 2.02.2020 #} 
	{{ pub_date|date:"j F Y" }} {# выведет 2 февраля 2020 #}
	{{ pub_date|date:"d.m.y" }} {# выведет 02.02.20 #}
	{{ pub_date|date:"d M Y" }} {# выведет 02 фев 2020 #}

Несколько фильтров сразу

Фильтры можно объединять в цепочку:

	{{ variable|title|truncatewords:4 }} 

Если переменная variable содержит строку ЭТО ОДиН маЛЕНЬкий шаг для чеЛОВека и
оГрОмНыЙ СКачОК для челоВЕЧЕсТВАа, то

    сначала фильтр title преобразует регистр букв в формат
		«каждое слово с заглавной» Это Один Маленький Шаг Для Человека И
		Огромный Скачок Для Человечества,
    а потом фильтр truncatewords:4 обрежет текст до первых четырёх слов.

В результате на страницу будет выведено Это Один Маленький Шаг.
В Django есть ещё множество встроенных фильтров, почитайте о них в документации,
это обязательно пригодится.
(https://docs.djangoproject.com/en/3.0/ref/templates/builtins/#ref-templates-builtins-filters)

Комментарии

Django-шаблоны поддерживают комментарии — строки, которые игнорируются при
интерпретации кода. Однострочные комментарии записываются между символами
{# и #}, многострочные — между конструкциями {% comment %} и {% endcomment %}.
Если строка не содержит переменных шаблона, можно использовать и стандартные
html- комментарии <!-- и -->.

	{% comment "Опциональный текст, комментарий к комментарию" %}
	  <p>Этот кусок шаблона временно отключен {{ create_date|date:"c" }}</p>
	  <p>Уходя, гасите свет.</p>
	{% endcomment %}

	{# Однострочный комментарий, пригодится для заметок **#}
	<!-- И это -- тоже комментарий --> 
