Подзапросы

Знакомьтесь: подзапросы!

Подзапрос — это запрос в запросе. Например, ассистент по актёрам собирает
портфолио с фото и пробами артистов, подходящих на роль Гамлета в новом фильме.
А затем режиссёр, изучив портфолио, приглашает на кастинг пятерых, с которыми
готов работать. Деятельность ассистента по актёрам — это подзапрос, или внутренний
запрос. А выбор лучшего Гамлета из пяти — внешний запрос. 

Подзапросы могут выполняться в разных частях запроса.
Если подзапрос записать в блоке FROM, то SELECT выберет данные из таблицы,
полученной в результате работы подзапроса. Имя этой таблицы указывают во
внутреннем запросе, к её столбцам обращаются во внешнем. Подзапрос записывают в
круглых скобках:

	SELECT 
	ПОДЗАПРОС_1.название_столбца, 
	ПОДЗАПРОС_1.название_столбца_2
	FROM -- Для лучшей читабельности кода, переносите подзапрос на новую строку
		-- отделяйте подзапросы отступами 
		(SELECT 
			название_столбца,
			название_столбца_2 
		FROM 
			название_таблицы
		WHERE 
			название_столбца = значение) AS ПОДЗАПРОС_1; 
	-- не забывайте давать имя подзапросу в блоке FROM 

id	Name	genre	author	date_pub	pages	price	rating
1	Капитанская дочка	5	Александр Пушкин	1836-01-01	130	150	4.7
2	Отцы и дети	1	Иван Тургенев	1861-01-01	240	207	4.7
3	Вишнёвый сад	7	Антон Чехов	1903-01-01	60	138	4.4
4	Война и мир	1	Лев Толстой	1869-01-01	1274	
5	Анна Каренина	1	Лев Толстой	1878-01-01	1000	126	4.6
6	Цветы для Элджернона	4	Дэниел Киз	1959-01-01	250	280	4.7
7	Похороните меня за плинтусом...	5	Павел Санаев	1994-01-01	184	198	4.1
8	Зелёная миля	9	Стивен Кинг	1996-01-01	420	190	4.8
9	Унесённые ветром	1	Маргарет Митчел	1936-01-01	624	358	
10	Три товарища	1	Эрих Мария Ремарк	1929-01-01	470	196	4.7
11	На Западном фронте без перемен	4	Эрих Мария Ремарк	1945-01-01	200	273	4.6
12	Триумфальная арка	1	Эрих Мария Ремарк	1956-01-01	520	220	4.7
13	Чёрный обелиск	1	Эрих Мария Ремарк	1961-01-01	480	420	4.6
14	Ночь в Лиссабоне	1	Эрих Мария Ремарк	1959-01-01	250	187	4.7
15	Жизнь взаймы	1	Эрих Мария Ремарк	1927-01-01	240	240	4.6
16	Станция на горизонте	1	Эрих Мария Ремарк	1830-01-01	210		4.1
17	Евгений Онегин	1	Александр Пушкин	1820-01-01	736	330	4.7

Напишем запрос, который подсчитает среднее количество проставленных оценок по жанрам
книг. Нужно вызвать две агрегирующие функции: COUNT() найдёт количество, AVG()
подсчитает среднее. Однако написать SELECT AVG(COUNT(rating)) не выйдет — получим
сообщение об ошибке: «агрегирующие функции не могут быть вложенными» (англ. ERROR:
aggregate function calls cannot be nested).

Сначала нужно вызвать актёров на пробы, а потом просмотреть пробы и выбрать лучшего.
Найдём количество оценок по жанрам в подзапросе, а во внешнем запросе рассчитаем
среднее полученных значений:

	SELECT 
		AVG(Sub.count_rating) AS avg_count_rating
	FROM
		(SELECT 
			genre
			COUNT(rating) AS count_rating
		FROM 
			books
		GROUP BY genre) AS Sub; 

Разберём результат работы внутреннего запроса:

GENRE	COUNT_RATING
5	2
1	9
7	1
4	2
9	1

В внутреннем запросе подсчитали число оценок книг каждого жанра и сохранили его
в поле count_rating. К таблице-результату работы подзапроса теперь можно обратиться
во внешнем запросе.

Вызовем столбец count_rating таблицы Sub (от англ. subquery, «подзапрос») и
найдём среднее функцией AVG():

	3 

Что это значит? Таблица содержит в среднем по 3 оценки, проставленные каждому жанру.
Внутренние запросы могут понадобиться в разных блоках внешнего запроса. Например,
устроим подзапрос в блоке WHERE. Тогда выберутся данные из столбца со значениями,
сгенерированными в результате работы подзапроса:

	SELECT 
		название_столбца, 
		название_столбца_1
	FROM 
		название_таблицы
	WHERE 
		название_столбца = 
			(SELECT 
				столбец_1
			FROM 
				название_таблицы_2 
			WHERE
				столбец_1  = значение); 

Дополним шаблон конструкцией IN, чтобы собирать данные из нескольких столбцов:

	SELECT 
		название_столбца, 
		название_столбца_1
	FROM 
		название_таблицы
	WHERE 
		название_столбца IN  
				(SELECT 
					столбец_1
				FROM 
					название_таблицы_2  
				WHERE 
					столбец_1 = значение_1 OR столбец_1 = значение_2); 

Пример: добавим к таблице books таблицу genre с кодами жанров и их названиями:

id	name
1	Роман
2	Басня
3	Комедия
4	Рассказ
5	Повесть
6	Поэма
7	Пьеса
8	Научно-образовательная
9	Драма
10	Сказка
11	Трагедия

Выберем книги жанра «Роман» из таблицы books:

	SELECT 
		name,
		genre 
	FROM 
		books
	WHERE 
		genre = 
				(SELECT 
					id 
				FROM 
					genre
				WHERE 
					name ='Роман');

Column 1	Column 2
1	Роман

Подзапрос указывает, что нужно выбрать из таблицы genre те id, которым
соответствует жанр — «Роман». Результат подзапроса: 1. Лишь одно значение из
таблицы genre означает романы.

Перейдём к внешнему запросу. Он выбирает названия и жанры из таблицы books.
Но только те, чей жанр равен результату внутреннего запроса, то есть единице.
Результат работы внешнего запроса:

name	genre
Отцы и дети	1
Война и мир	1
Анна Каренина	1
Унесенные ветром	1
Три товарища	1
Триумфальная арка	1
Черный обелиск	1
Ночь в Лиссабоне	1
Жизнь взаймы	1
Станция на горизонте	1
Евгений Онегин	1

Напишем похожий запрос. Выберем не только романы, но и повести с драмами.
Вот где пригодится IN:

	SELECT 
		name, 
		genre 
	FROM 
		books
	WHERE 
		genre IN 
				(SELECT 
					id
				FROM 
					genre
				WHERE 
					name IN ( 'Роман', 'Драма', 'Повесть' )); 

Конструкция IN во внутреннем запросе выбирает id из таблицы жанров с названиями
'Роман', 'Драма' или 'Повесть'. В результате получим три id: 1, 9, 5. Эти значения
передаются во внешний запрос.

Внешний запрос сообщает, что нужно выбрать названия и жанры из таблицы books,
где жанры равны значениям из результирующего списка внутреннего запроса.
То есть, 1, 9 или 5.

name	genre
Капитанская дочка	5
Отцы и дети	1
Война и мир	1
Анна Каренина	1
Похороните меня за плинтусом...	5
Зеленая миля	9
Унесенные ветром	1
Три товарища	1
Триумфальная арка	1
Черный обелиск	1
Ночь в Лиссабоне	1
Жизнь взаймы	1
Станция на горизонте	1
Евгений Онегин	1

===============================================================================
Тренажер

Задача 1/4:

Руководитель отдела хочет получить списки покупателей, которые предпочитают
товары премиум-сегмента. И сводку о том, сколько в среднем транзакций совершают
пользователи за неделю. Вперёд, к изучению целевой аудитории!

Напишите запрос, который выберет из таблицы products_data_all идентификаторы
продуктов (id_product) категории 'молоко и сливки' дороже 120 рублей или категории
'масло сливочное и маргарин' дороже 354 рублей.

Напомним названия полей:

    категория — category;
    цена — price.

Подсказка:

Cгруппируйте условия в блоке WHERE так: (условие_1 AND условие_2)
OR (условие_3 AND условие_4).

	SELECT
		id_product
	FROM 
		products_data_all
	WHERE
		(category = 'молоко и сливки' AND price > 120) OR
		(category = 'масло сливочное и маргарин' AND price > 354)

Задача 2/4:

Напишите запрос, который выберет из таблицы transactions уникальные идентификаторы
пользователей (user_id), приобретавших продукты (id_product) категории 'молоко
и сливки' дороже 120 рублей или категории 'масло сливочное и маргарин'
дороже 354 рублей.

Подсказка:

Некоторые пользователи могли покупать продукты премиум-сегмента несколько раз.
Чтобы включить их в выборку только 1 раз, примените команду DISTINCT к полю
user_id в блоке SELECT. В блоке WHERE задействуйте конструкцию IN.

	SELECT 
		DISTINCT user_id
	FROM 
		transactions
	WHERE 
		id_product IN
		(SELECT 
		id_product 
		FROM 
		products_data_all
		WHERE 
		(category='молоко и сливки' AND  price > 120) OR 
		(category='масло сливочное и маргарин' AND price > 354));

Задача 3/4:

Напишите запрос для подсчёта числа уникальных транзакций id_transaction из
таблицы transactions. Сгруппируйте количество транзакций по дням: усеките
столбец date до дня. Назовите сгенерированный столбец с транзакциями
transaction_per_day, а усечённую дату — trunc_date.
Выводите столбцы в таком порядке: сначала transaction_per_day, а затем trunc_date.

Подсказка:

Примените DISTINCT для подсчёта уникальных значений транзакций. Вызовите функцию
DATE_TRUNC с аргументами 'day' и date, чтобы усечь данные столбца date до дня.
Назовите переменную с усечённой датой trunc_date и сгруппируйте данные по ней.

	SELECT  
		COUNT(DISTINCT id_transaction) AS transaction_per_day,
		DATE_TRUNC('day', date) AS trunc_date
	FROM
		transactions
	GROUP BY
		trunc_date

Задача 4/4:

Превратите запрос прошлого задания в подзапрос блока FROM. Назовите результат
выполнения подзапроса SUBQ.

Во внешнем запросе:

    Вызовите функцию EXTRACT, чтобы извлечь номер недели из столбца trunc_date в
		таблице SUBQ. Результирующее поле назовите week_number.
    Найдите среднее столбца transaction_per_day таблицы SUBQ и сохраните в
		переменной avg_week_transaction.
    Сгруппируйте данные по week_number.

Подсказка:

Вызовите функцию EXTRACT с аргументом WEEK FROM SUBQ.trunc_date. Функцию AVG()
примените к значениям столбца SUBQ.transaction_per_day.

	SELECT
		EXTRACT(week FROM SUBQ.trunc_date) AS week_number,
		AVG(SUBQ.transaction_per_day) AS avg_week_transaction
	FROM
		(SELECT  
			COUNT(distinct id_transaction) as transaction_per_day,
			DATE_TRUNC('day', date) AS trunc_date
		FROM
			transactions
		GROUP BY
			trunc_date) AS SUBQ
	GROUP BY
		week_number
===============================================================================
