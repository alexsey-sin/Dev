Наследование в ООП

Гибкость объектно-ориентированного программирования проявляется в наследовании.
Так называют возможность на основе существующих классов создавать классы-наследники,
изменяя свойства и методы родительских классов, и добавляя новые.

Наследование организует иерархическую структуру проекта. Разработчик определяет
классу-родителю основные свойства и методы, к которым можно обращаться в объектах
любого из дочерних классов.

см. скрин_1.jpg

Синтаксис наследования в Python выглядит так:

	# у класса может быть несколько родительских классов
	class <Имя нового_класса>(<Имя класса-родителя 1>[, <Имя класса-родителя 2>, ...]): 
		<тело класса>

Пример:

	class User:
		def __init__(self, name, phone):
			self.name = name
			self.phone = phone

		def show(self):
			print(f'{self.name} ({self.phone})')


	# объявляем класс Friend, дочерний по отношению к классу User
	class Friend(User):
		def show(self):
			print(f'Имя: {self.name} || Телефон: {self.phone}')


	# создаём объекты User и Friend
	father = User('Дюма-отец', '+33 3 23 96 23 30')
	son = Friend('Дюма-сын', '+33 3 23 96 23 30')

Класс User — родительский для класса Friend. Все свойства и методы родительского
класса наследуются: в объектах класса Friend мы можем обращаться к свойствам
name и phone, а также вызывать метод show().

Но в классе Friend метод show сработает иначе, чем в классе User: этот метод был
переопределён, описан заново, и данные на экран выведутся в другом формате.

	# вызываем метод show() класса User (родительского)
	father.show()
	# результат: 
	# Дюма-отец (+33 3 23 96 23 30)

	# вызываем метод show() класса Friend (дочернего)
	son.show() 
	# результат выглядит иначе, чем у объекта User: 
	# Имя: Дюма-сын || Телефон: +33 3 23 96 23 30 

Отношения между двумя этими классами принято описывать так:

    User является родительским классом для Friend;
    Friend является дочерним классом для User, или Friend наследуется от User.

Предположим, в объектах класса Friend вы хотите сохранять не только имя и телефон,
но и адрес. Значит, при создании экземпляра класса Friend нужно передавать параметр
address. Но конструктор родительского класса принимает только name и phone.

В этом случае поможет переопределение родительского конструктора, функции __init__.

	class User:
		def __init__(self, name, phone):
			self.name = name
			self.phone = phone

		def show(self):
			print(f'{self.name} ({self.phone})')


	# наследуем класс Friend от User
	class Friend(User):
		# Пишем конструктор класса-наследника,
		# чтобы он принимал все нужные параметры
		def __init__(self, name, phone, address):
			# наследуем функциональность конструктора из класса-родителя
			super().__init__(name, phone)
			# добавляем новую функциональность: свойство address
			self.address = address

		# полностью переопределяем родительский метод show()
		def show(self):
			print(f'Имя: {self.name} || '
				  f'Телефон: {self.phone} || '
				  f'Адрес: {self.address}')

При создании экземпляра класса Friend будет вызван конструктор класса __init__.

Первым делом в нём вызывается функция super(), в неё передаются значения
name и phone. При этом происходит вызов конструктора родительского класса и
его функциональность сохраняется в классе-наследнике.

Так можно вызвать не только конструктор, но и любой другой метод родительского
класса, ведь конструктор — это тоже метод класса, хоть и немного особенный.

После вызова super() сохраняем значение address в свойство self.address.

Теперь мы можем одинаково обращаться к любому из трех полей, как к унаследованным,
так и к добавленному. Например, в методе show() мы можем напечатать адрес друга.

Если в дочернем классе вы хотите сохранить функциональность класса-родителя, то в
дочернем классе нужно вызвать функцию super(), как в примере с конструктором.

Если же вы хотите полностью изменить поведение конструктора класса или иного метода,
то вызывать super() нет необходимости, в этом случае нужно полностью написать
конструктор дочернего класса.

Именно это мы и сделали в примере, но не для конструктора, а для метода show():
мы перезаписали его полностью.

Важные термины

На собеседованиях или при чтении научной литературы потребуется знать основные
термины теории ООП.

Интерфейс класса — это функциональная часть класса, через которую происходит
взаимодействие с самим классом или с экземпляром этого класса.

Описывая класс, разработчик одновременно создает интерфейс для обращения к этому
классу и к его экземплярам. Для класса User интерфейсом будут те части класса
или объекта, с которыми может взаимодействовать другой код:

	class Bird:
		#  Это конструктор, он вызывается при создании объекта
		def __init__(self, name, size):
			self.name = name
			self.size = size

		def show(self):
			# Вызывается для вывода на экран всех свойств объекта
			# это интерфейс класса, к нему можно обратиться из внешнего кода
			print(f'{self.name} носит одежду размера "{self.size}".')


	# Создание объекта
	sparrow = Bird('Воробей', 'S')
	# Теперь можно воспользоваться его внешним интерфейсом: методом show()
	sparrow.show()

	# Результат: Воробей носит одежду размера "S".

Наследование — способ описать новый класс на базе существующего. При этом в
дочернем классе можно сохранить или переопределить свойства и методы родительского
класса.

Механизм наследования прозрачен: если функция или свойство родительского класса
ещё раз описаны в дочернем классе, то этот метод или это свойство будут
переопределены. А остальные свойства и методы будут работать точно так же, как у
класса-родителя.

	class Bird:
		def __init__(self, name, size):
			# Это конструктор, он вызывается при создании объекта
			self.name = name
			self.size = size

		def show(self):
			# Вызывается для вывода на экран всех свойств объекта
			print(f'{self.name} носит одежду размера {self.size}.')


	class Parrot(Bird):
		def __init__(self, name, size, sound):
			super().__init__(name, size)
			self.sound = sound

		def show(self):
			# Вызывается для вывода на экран всех свойств объекта
			print(f'{self.name} носит одежду размера {self.size} и {self.sound}.')


	# Создание объектов
	sparrow = Bird('Воробей', 'S')
	ara = Parrot('Попугай ара', 'XL', 'разговаривает')
	nymphicus = Parrot('Попугай Корелла', 'S', 'щебечет')

	# Теперь можно воспользоваться его внешним интерфейсом: методом show()
	sparrow.show()
	ara.show()
	nymphicus.show()

	# Результат:
	# Воробей носит одежду размера S.
	# Попугай ара носит одежду размера XL и разговаривает.
	# Попугай Корелла носит одежду размера S и щебечет.

Инкапсуляция — объединение и скрытие методов и свойств, и предоставление
доступа к ним через простой внешний интерфейс.

Даже не имея понятия, как работают методы lower, upper или split объекта
типа str, мы из документации знаем о них и можем управлять объектом.
Методы «инкапсулированы», а разработчику предоставлен интерфейс для их вызова:
string.upper() А класс Parrot инкапсулирует свойства попугая name, size, sound,
и его метод show(): совершенно необязательно знать, как они работают, можно просто
обратиться к ним и получить результат: ara.show()

Полиморфизм — возможность взаимодействовать с объектами разных типов через
одинаковые интерфейсы, обращаться к свойствам и методам, общим для всех объектов.

В примере с птичками от класса Bird наследуются классы Parrot и Predator,
а от Predator наследуется класс Egg.

К какому бы наследнику класса Bird мы ни обратились через интерфейсы name
или show() — мы получим ответ (или, как минимум, не получим ошибку),
потому что мы предусмотрительно реализовали принцип полиморфизма:
у всех наследников класса Bird есть эти интерфейсы.

	class Bird:
		def __init__(self, name, size):
			self.name = name
			self.size = size

		def show(self):
			print(f'{self.name} носит одежду размера {self.size}.')


	class Parrot(Bird):
		def __init__(self, name, size, sound):
			super().__init__(name, size)
			self.sound = sound

		def show(self):
			print(f'{self.name} носит одежду размера {self.size} и {self.sound}.')


	class Predator(Bird):
		def __init__(self, name, size, claws_size):
			super().__init__(name, size)
			self.claws_size = claws_size

		def show(self):
			print(f'{self.name} носит одежду размера {self.size} и '
				  f'когти размера {self.claws_size}.')


	class Egg(Predator):
		def show(self):
			print(f'Из яйца вылупится птичка {self.name} размера {self.size} с '
				  f'когтями размера {self.claws_size}.')

===============================================================================
Тренажер

Задача 1/3:

Запустите код и убедитесь, что на экран выведены данные одного и того же
пользователя, но в разных форматах.
Когда будете готовы, нажимайте «Проверить» и «Далее».

Подсказка:

Запустите код и убедитесь, что на экран выведены данные одного и того же
пользователя, но в разных форматах.

	class User:
		def __init__(self, name, phone):
			self.name = name
			self.phone = phone

		def show(self):
			print(f'{self.name} ({self.phone})')


	class Friend(User):
		def show(self):
			print(f'Имя: {self.name} || Телефон: {self.phone}')


	user = User("Виктор Гюго", "+33 1 42 72 10 16")
	# у класса friend нет конструктора, но он есть
	# у родительского класса User, поэтому код сработает
	friend = Friend("Виктор Гюго", "+33 1 42 72 10 16")

	user.show()
	friend.show()

Задача 2/3:

В коде описан класс Point (точка на карте), у него есть свойства — широта и
долгота, и метод distance(self, other) — это расстояние между двумя точками
в километрах (параметр other должен получить другой объект Point).

Создайте два класса-наследника класса Point:

    City(Point, name, population) описывает город, в конструктор передаются
		координаты города (объект класса Point), его название и численность
		населения.
    Mountain(Point, name, height) описывает гору, в конструктор передаются
		координаты горы (объект класса Point), её название и высота в метрах.

Ваша задача — вывести на экран расстояние от Москвы до Эвереста.

Подсказка:

    В конструкторе класса City присвойте значения полям self.name и self.population.
		Затем вызовите конструктор родительского класса с аргументами «широта»
		и «долгота»: super().__init__(latitude, longitude)
    Конструктор класса Mountain должен принять на вход широту, долготу, название
		горы и её высоту: def __init__(self, latitude, longitude, name, height):
    Опишите метод show() в классе Mountain.

# импортируем функции из библиотеки math для рассчёта расстояния
from math import radians, sin, cos, acos


	class Point:
		def __init__(self, latitude, longitude):
			self.latitude = radians(latitude)
			self.longitude = radians(longitude)

		# считаем расстояние между двумя точками в км
		def distance(self, other):
			cos_d = sin(self.latitude) * sin(other.latitude) + cos(self.latitude) * cos(other.latitude) * cos(
			self.longitude - other.longitude)

			return 6371 * acos(cos_d)


	class City(Point):
		def __init__(self, latitude, longitude, name, population):
			super().__init__(latitude, longitude)
			self.name = name
			self.population = population
			# допишите код: сохраните свойства родителя
			# и добавьте свойства name и population

		def show(self):
			print(f"Город {self.name}, население {self.population} чел.")


	class Mountain(Point):
		def __init__(self, latitude, longitude, name, height):
			super().__init__(latitude, longitude)
			self.name = name
			self.height = height
		# допишите код: напишите конструктор, в нём сохраните свойства родителя
		# и добавьте свойства name и height

		# Создайте метод show(self):
		# информацию о горе нужно вывести в формате:
		# "Высота горы <название> - <высота> м."
		def show(self):
			print(f"Высота горы {self.name} - {self.height} м.")


	# эта функция печатает расстояние
	# между двумя любыми наследниками класса Point
	def print_how_far(geo_object_1, geo_object_2):
		print(f'От точки «{geo_object_1.name}» до точки «{geo_object_2.name}» — {geo_object_1.distance(geo_object_2)} км.')


	# основной код
	moscow = City(55.7522200, 37.6155600, 'Москва', 12615882)
	everest = Mountain(27.98791, 86.92529, 'Эверест', 8848)
	chelyabinsk = City(55.154, 61.4291, 'Челябинск', 1200703)

	moscow.show()
	everest.show()
	print_how_far(moscow, everest)
	print_how_far(moscow, chelyabinsk)

Задача 3/3:

Опишите на ООП взаимодействие студента, ментора, код-ревьюера и куратора.

Все эти люди — люди, поэтому создадим базовый класс Human, со свойством name
(у каждого человека должно быть имя) и методом answer_question() для ответов
на вопросы.

По умолчанию объект Human будет отвечать на любой вопрос так: «Очень
интересный вопрос! Не знаю.»

От класса Human унаследуем классы Student, Mentor, CodeReviewer и Curator.

Student должен уметь задавать вопросы. Реализуйте в классе Student метод
ask_question(Human, question). При вызове этот метод должен:

    Напечатать на экране вопрос в формате <имя человека, которому задаём вопрос>,
		<текст вопроса>
    Задать вопрос question человеку, объекту класса Human. Имя объекта,
		которому адресован вопрос, передаётся при вызове метода ask_question().

Объекты классов Mentor, CodeReviewer и Curator должны уметь отвечать на
вопросы при вызове метода answer_question(). Задан непредусмотренный вопрос
— для него подойдет ответ по умолчанию.

После того, как вы допишете код, ваша программа должна вывести на экран такой текст:

	Марина, мне грустненько, что делать?
	Держись, всё получится. Хочешь видео с котиками?

	Ира, мне грустненько, что делать?
	Отдохни и возвращайся с вопросами по теории.

	Евгений, когда каникулы?
	Очень интересный вопрос! Не знаю.

	Евгений, что не так с моим проектом?
	О, вопрос про проект, это я люблю.

	Виталя, как устроиться на работу питонистом?
	Очень интересный вопрос! Не знаю.

	Ира, как устроиться работать питонистом?
	Сейчас расскажу.

	class Human:
		def __init__(self, name):
			self.name = name

		# ответ по умолчанию для всех одинаковый, можно 
		# доверить его родительскому классу
		def answer_question(self, question):
			print('Очень интересный вопрос! Не знаю.')


	class Student(Human):
		#  метод ask_question() принимает параметр someone:
		#  это объект, экземпляр класса Curator, Mentor или CodeReviewer,
		#  которому Student задаёт вопрос; 
		#  параметр question — это просто строка
		#  имя объекта и текст вопроса задаются при вызове метода ask_question
		def ask_question(self, someone, question):
			# напечатайте на экран вопрос в нужном формате
			print(f'{someone.name}, {question}')
			# запросите ответ на вопрос у someone
			someone.answer_question(question)
			print()  # этот print выводит разделительную пустую строку	


	class Curator(Human):
		def answer_question(self, question):
			if question == 'мне грустненько, что делать?':
				print('Держись, всё получится. Хочешь видео с котиками?')
			else:
				super().answer_question(question)
			# здесь нужно проверить, пришёл куратору знакомый вопрос или нет
			# если да - ответить на него
			# если нет - вызвать метод answer_question() у родительского класса

	# объявите и реализуйте классы CodeReviewer и Mentor
	class CodeReviewer(Human):
		def answer_question(self, question):
			if question == 'что не так с моим проектом?':
				print('О, вопрос про проект, это я люблю.')
			else:
				super().answer_question(question)

	class Mentor(Human):
		def answer_question(self, question):
			if question == 'мне грустненько, что делать?':
				print('Отдохни и возвращайся с вопросами по теории.')
			elif question == 'как устроиться работать питонистом?':
				print('Сейчас расскажу.')
			else:
				super().answer_question(question)
				

	# следующий код менять не нужно, он работает, мы проверяли
	student1 = Student('Тимофей')
	curator = Curator('Марина')
	mentor = Mentor('Ира')
	reviewer = CodeReviewer('Евгений')
	friend = Human('Виталя')

	student1.ask_question(curator, 'мне грустненько, что делать?')
	student1.ask_question(mentor, 'мне грустненько, что делать?')
	student1.ask_question(reviewer, 'когда каникулы?')
	student1.ask_question(reviewer, 'что не так с моим проектом?')
	student1.ask_question(friend, 'как устроиться на работу питонистом?')
	student1.ask_question(mentor, 'как устроиться работать питонистом?')
===============================================================================
