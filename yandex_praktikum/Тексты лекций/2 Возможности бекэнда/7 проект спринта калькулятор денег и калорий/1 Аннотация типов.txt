Аннотация типов. Простые типы

Никто не застрахован от ошибок в коде. Иногда ценой этой ошибки будет просто
нечитаемость кода, а иногда — разбившийся космический корабль. Без инструментов
анализа нельзя быть уверенным, что всё работает правильно.

Одна из возможных проблем — ошибка в типах данных.

Python поддерживает динамическую типизацию. Это означает, что переменная может
менять свой тип в зависимости от последнего присвоенного ей значения.

	# Создана переменная, ей присвоено значение типа string
	var = "string here"

	# Переменной присваивается новое значение, и вот уже тип данных — integer
	var = 1234 

Обычно это удобно, но иногда становится отличным способом выстрелить себе в ногу.
Посмотрите на поведение простой функции:

	def we_crash_all(name):
		return 'Привет, ' + name + ', мы всё сломали!'


	print(we_crash_all('Наташа')) 

Хорошая функция, отлично работает.

Но никто не мешает передать в функцию we_crash_all() булеву переменную
(разработчик вполне может не учесть возможность такого события):

	print(we_crash_all(True))
	>>> TypeError: can only concatenate str (not "bool") to str 

Ошибка!

В Python нельзя просто взять и сложить str c bool. Функция ожидала на вход строку,
а пришло булево значение.

Если кода немного — этот «выстрел» несложно предотвратить. Но когда в проекте
будут взаимодействовать множество функций, классов и переменных — это станет
серьёзной проблемой.

Другой пример: функция dependency_func() принимает на вход объект и ожидает,
что у этого объекта есть метод work(). Но по ошибке в эту функцию можно передать
число или объект, в котором нет ожидаемого метода.

	class WeirdObject:
		def work(self):
			print('Работает')


	def dependency_func(obj):
		obj.work()


	dependency_func(WeirdObject())
	>>> Работает

	dependency_func(11) # AttributeError: 'int' object has no attribute 'work'

Привет, name, мы всё сломали.

Type Hints: аннотация типов данных

Чтобы держать типизацию под контролем — применяют аннотации типов данных.

Аннотация типов данных (Type Hints, дословно по-английски — «подсказки типов»)
— это явное указание типа ожидаемых данных при объявлении переменных, классов
и функций. 

	# Без аннотации: объявили переменную, 
	# а Python сам догадался, какой в ней тип данных
	birth_year = 1971

	# С аннотацией: объявили переменную и указали, 
	# что это переменная - только для целых чисел
	birth_year: int = 1971

При выполнении кода Python игнорирует аннотации типов и не выдаёт ошибок,
если типизация нарушена:

	# Переменная var_for_bool аннотирована как булева, но в неё передана строка
	var_for_bool: bool = 'Чистая правда, клянусь'

	# Python не обратит внимания на это несоответствие 
	# и продолжит выполнять код, как ни в чём не бывало. 

Однако Python не оставляет аннотации совсем без внимания: он считывает Type Hints
и сохраняет их в словарь __annotations__. Содержимое этого словаря можно вывести
на экран:

	# Аннотация переменной name: "это строка"
	whois: str = 'Наташа'

	# Аннотация переменной var_for_bool: "это булева переменная"
	var_for_bool: bool = True

	# Можно напечатать аннотации переменных из глобальной области видимости
	print(__annotations__)
	>>> {'whois': <class 'str'>, 'var_for_bool': <class 'bool'>} 

Ну и кому нужны эти Type Hints?

Если Python игнорирует аннотации типов, а разработчик и без аннотаций старается
отслеживать корректность кода — какой прок в этих Type Hints?

Аннотации типов могут считываться сторонними программами, предназначенными для
проверки типизации. В случае обнаружения ошибок эти программы сообщат разработчику
о проблемах.

Есть по крайней мере четыре популярных пакета для проверки типов: 

    Mypy активно разрабатывается, в частности, Гвидо ван Россумом, создателем Python.
    Pyre был разработан в Facebook как альтернатива mypy.
    Pytype — анализатор от Google.
    Pylance — разработан корпорацией Майкрософт.

Эти пакеты могут работать и в консоли, и в IDE для Python (например Pylance в
Visual Studio Code). Такие пакеты подсвечивают некорректный код или выдают
подсказки в процессе набора текста.

Стоит рассматривать инструмент для проверки типов как дополнительный линтер,
необязательный, но полезный.

Синтаксис аннотирования встроенных типов данных

В простейшем случае аннотация содержит непосредственно ожидаемый тип данных:
str, int, float и bool. Дополнительно применяется обозначение None, «ничего»:
например, если функция ничего не возвращает — тип возвращаемых данных указывается
как None.

Type Hints для переменных

	<имя переменной>: <принимаемый тип> = <значение>

	var_integer: int = 10  # Только целочисленные значения
	var_float: float = 10.0  # Числа с плавающей точкой (включая целые, можно передать 10)
	var_flag: bool = True  # Логический тип
	var_string: str = 'Йя строка'  # Строки

В Python есть и другой синтаксис аннотирования, вы можете встретить его в работе.
Этот синтаксис устарел, но вполне валиден и нормально обрабатывается пакетами для
проверки типов.

	# Вариант 1
	<имя переменной>: <принимаемый тип>
	<имя переменной> = <значение>
	# Вариант 2: тип данных указывается после символа #
	<имя переменной> = <значение>  # type: <принимаемый тип>

	# На примере birth_year типа int со значением 1971 синтаксис будет выглядить так:
	# Вариант 1 
	birth_year: int 
	birth_year = 1971

	# Вариант 2 (устаревший, использовался до python 3.5)
	birth_year = 1971  # type: int

Type Hints для функций
В функциях указывают Type Hints для аргументов и для возвращаемого значения.

	def <имя функции>(<аргумент>: <тип>) -> <возвращаемый тип>:

	def is_rhomb(a_size: float, b_size: float) -> bool:
		"""Проверяет, является ли параллелограмм ромбом."""
		# Вернёт True или False в зависимости от истинности выражения
		return a_size == b_size  
	 

	# Функция print_hi() ожидает строковый аргумент, 
	# значение этого аргумента по умолчанию - 'stranger'.
	# Функция ничего не возвращает, и для неё тип возвращаемых данных - None
	def print_hi(name: str = 'stranger') -> None:
		print('Hi,' + name + '!')

	# Можно напечатать типы данных функций
	print(is_rhomb.__annotations__)
	>>> {'a_size': <class 'float'>, 'b_size': <class 'float'>, 'return': <class 'bool'>}

	print(print_hi.__annotations__)
	>>> {'name': <class 'str'>, 'return': <class 'None'>}

Type Hints для классов
В классах аннотируются все объявляемые переменные и методы. Синтаксис Type Hints
для внутренних переменных и методов класса — точно такой же, как и для обычных
переменных и функций.

	class <имя класса>:
		<имя переменной>: <принимаемый тип>
		def __init__(self, <имя переменной>: <принимаемый тип>) -> None:
			self.<имя переменной> = <имя переменной>

	# В классе Hello инциализирована строчная переменная x
	# со значением по умолчанию 'привет'.
	# self в классах никогда не аннотируется.
	# __init__ ничего не возвращает.
	class Hello:
		x: str # Если здесь не указывать тип переменной,
			   # аннотация для x не отобразится в словаре __annotations__,
			   # однако анализатор возьмёт аннотацию из __init__ и корректно отработает

		def __init__(self, x: str = 'Привет') -> None:
			self.x = x

	# Вывод на экран словаря __annotations__ из области видимости класса Hello
	print(Hello.__annotations__)
	>>> {'x': <class 'str'>}

Проверка аннотации типов через консоль
Теперь можно проверить, как работает проверка типизации. Скопируйте этот код в
какой-нибудь временный файл и сохраните его под именем temp.py (или любым другим):

	def we_crash_all(name: str) -> str:    
		return 'Привет, ' + name + ', мы всё сломали!'


	print(we_crash_all('Наташа'))

Установите пакет mypy (нужен Python 3.5 +):

	$ pip install mypy 

Откройте терминал, перейдите в директорию с временным файлом, в котором вы
работали с функцией we_crash_all(), и запустите этот файл утилитой mypy.

	$ mypy temp.py
	Success: no issues found in 1 source file 

Файл проверен, ошибок в типизации не найдено.
Вызовите функцию с другим аргументом:

	def we_crash_all(name: str) -> str:    
		return 'Привет, ' + name + ', мы всё сломали!'


	print(we_crash_all(100)) 

Сохраните файл и снова запустите файл в mypy:

	$ mypy temp.py
	temp.py:5: error: Argument 1 to "we_crash_all" 
	has incompatible type "int"; expected "str"
	Found 1 error in 1 file (checked 1 source file) 

Утилита mypy сделала своё дело:

    обнаружила, что в функцию передали число, хотя ожидалась строка;
    указала на суть ошибки и на строку, в которой допущена ошибка.

Проверка типизации через IDE
Проверить типизацию можно прямо в IDE, не запуская дополнительные приложения:
линтер mypy можно подключить к редактору кода, и тогда проверка типизации будет
проходить «на лету», прямо в момент написания кода.

В Visual Studio Code в качестве линтера укажите mypy:
Ctrl+Shift+P → Python: Select Linter mypy

Теперь mypy будет постоянно наблюдать за кодом, который вы пишете, а при виде
ошибки будет нервничать и, не ожидая выполнения кода, сообщать о проблеме:
подчеркнёт ошибку в коде и покажет детальное описание в панели «Проблемы» (Problems).

===============================================================================
Тренажер

Задача:

Напишите аннотацию типов для класса Contact.

Подсказка:

Аннотации переменных класса указываются в функции __init__ self не аннотируется.
__init__ ничего не возвращает. Не забудьте аннотировать возвращаемые значения
функций.

	class Contact:
		def __init__(self,
					 name: str,
					 year_birth: int,
					 is_programmer: bool) -> None:
			self.name = name
			self.year_birth = year_birth
			self.is_programmer = is_programmer

		def age_define(self) -> str:
			if 1946 < self.year_birth < 1980:
				return 'Олдскул'
			if self.year_birth >= 1980:
				return 'Молодой'
			return 'Старейшина'

		def programmer_define(self) -> str:
			if self.is_programmer:
				return 'Программист'
			return 'Нормальный'

		def show_contact(self) -> str:
			return(f'{self.name}, '
				   f'категория: {self.age_define()}, '
				   f'статус: {self.programmer_define()}')

		def print_contact(self) -> None:
			print(self.show_contact())
===============================================================================
